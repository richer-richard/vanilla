<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake ‚Äî Play | VANILLA</title>
    <link rel="icon" type="image/svg+xml" href="../favicon.svg">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700;800&family=Press+Start+2P&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../styles.css">
    <style>
        body {
            min-height: 100vh;
        }

        header {
            padding: 16px 28px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: linear-gradient(90deg, rgba(102, 126, 234, 0.12), rgba(118, 75, 162, 0.1));
            border-bottom: 1px solid rgba(102, 126, 234, 0.3);
            position: sticky;
            top: 0;
            z-index: 5;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .crumb {
            color: #cdd2f1;
            letter-spacing: 0.6px;
            font-size: 12px;
        }

        .pill {
            padding: 10px 14px;
            border-radius: 12px;
            border: 1px solid rgba(102, 126, 234, 0.4);
            background: rgba(102, 126, 234, 0.12);
            color: #dfe4ff;
            font-weight: 700;
            font-size: 12px;
            letter-spacing: 0.4px;
        }

        .pill-link {
            text-decoration: none;
            color: #dfe4ff;
            border: 1px solid rgba(102, 126, 234, 0.4);
            padding: 10px 12px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.04);
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            letter-spacing: 0.8px;
            transition: all 0.2s ease;
        }

        .pill-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 24px rgba(0, 0, 0, 0.35);
            border-color: rgba(118, 75, 162, 0.75);
        }

        .header-actions {
            display: flex;
            gap: 10px;
        }

        .action-btn {
            padding: 10px 14px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.24), rgba(118, 75, 162, 0.2));
            color: #f2f4ff;
            font-weight: 700;
            letter-spacing: 0.3px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .action-btn.ghost {
            background: rgba(255, 255, 255, 0.06);
            border-color: rgba(255, 255, 255, 0.1);
        }

        .action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
        }

        main {
            width: min(1200px, 100%);
            margin: 0 auto;
            padding: 26px 24px 60px;
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 18px;
            align-items: start;
        }

        @media (max-width: 980px) {
            main {
                grid-template-columns: 1fr;
            }
        }

        .glass-card {
            background: linear-gradient(150deg, rgba(255, 255, 255, 0.02), rgba(102, 126, 234, 0.08));
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            box-shadow: 0 25px 70px rgba(0, 0, 0, 0.35), 0 10px 22px rgba(102, 126, 234, 0.1);
            padding: 18px;
            position: relative;
            overflow: hidden;
        }

        .glass-card::after {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 12% 18%, rgba(118, 75, 162, 0.14), transparent 32%),
                        radial-gradient(circle at 82% 8%, rgba(102, 126, 234, 0.12), transparent 30%);
            pointer-events: none;
        }

        .glass-card > * {
            position: relative;
            z-index: 1;
        }

        .hud {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-bottom: 12px;
        }

        .stat {
            padding: 12px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            background: rgba(255, 255, 255, 0.03);
        }

        .stat .label {
            font-size: 11px;
            color: #adb6da;
            letter-spacing: 0.6px;
            text-transform: uppercase;
        }

        .stat .value {
            font-size: 22px;
            font-weight: 800;
            margin-top: 4px;
        }

        .board-shell {
            margin-top: 8px;
            background: radial-gradient(circle at 20% 20%, rgba(102, 126, 234, 0.16), transparent 35%),
                        radial-gradient(circle at 80% 10%, rgba(118, 75, 162, 0.16), transparent 30%),
                        rgba(6, 9, 25, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            padding: 14px;
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.03);
        }

        canvas {
            width: 100%;
            height: auto;
            aspect-ratio: 1 / 1;
            display: block;
            border-radius: 12px;
            background: #050913;
        }

        .help-text {
            margin-top: 10px;
            color: #aeb7db;
            font-size: 13px;
            letter-spacing: 0.2px;
        }

        .sidebar h2 {
            margin: 6px 0 12px;
            font-size: 20px;
        }

        .tips {
            list-style: none;
            padding-left: 0;
            display: flex;
            flex-direction: column;
            gap: 10px;
            color: #cbd0ea;
        }

        .tips li {
            padding: 10px 12px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            background: rgba(255, 255, 255, 0.03);
        }

        .chip-row {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 14px;
        }

        .chip {
            padding: 8px 12px;
            border-radius: 10px;
            border: 1px solid rgba(102, 126, 234, 0.35);
            background: rgba(102, 126, 234, 0.08);
            color: #dfe4ff;
            font-weight: 600;
            font-size: 12px;
        }

        .eyebrow {
            letter-spacing: 1px;
            text-transform: uppercase;
            color: #9fb0ff;
            font-size: 11px;
        }
    </style>
</head>
<body class="game-page">
    <header>
        <div class="header-left">
            <a class="pill-link" href="../games.html">‚Üê Games</a>
            <span class="crumb">Snake</span>
            <span class="pill" id="difficultyLabel">Medium Grid</span>
        </div>
        <div class="header-actions">
            <button class="action-btn ghost" id="soundBtn" title="Toggle Sound">üîä</button>
            <button class="action-btn ghost" id="pauseBtn">Pause</button>
            <button class="action-btn" id="restartBtn">Restart</button>
        </div>
    </header>

    <main>
        <section class="glass-card">
            <div class="hud">
                <div class="stat">
                    <div class="label">Score</div>
                    <div class="value" id="score">0</div>
                </div>
                <div class="stat">
                    <div class="label">Best</div>
                    <div class="value" id="best">0</div>
                </div>
                <div class="stat">
                    <div class="label">Length</div>
                    <div class="value" id="length">0</div>
                </div>
                <div class="stat">
                    <div class="label">Pace</div>
                    <div class="value" id="pace">--</div>
                </div>
            </div>
            <div class="board-shell" style="position: relative;">
                <canvas id="board"></canvas>
                <div class="canvas-overlay active" id="startOverlay" style="position: absolute; inset: 14px; border-radius: 12px; display: grid; place-items: center; background: radial-gradient(circle at 20% 15%, rgba(78, 205, 196, 0.14), transparent 45%), radial-gradient(circle at 78% 22%, rgba(157, 232, 199, 0.14), transparent 50%), rgba(4, 7, 16, 0.82); border: 1px solid rgba(255, 255, 255, 0.08); backdrop-filter: blur(10px); padding: 16px; z-index: 10;">
                    <div style="width: min(420px, 100%); border-radius: 16px; border: 1px solid rgba(255, 255, 255, 0.10); background: rgba(255, 255, 255, 0.05); box-shadow: 0 26px 70px rgba(0, 0, 0, 0.45); padding: 24px; text-align: center;">
                        <div style="letter-spacing: 1px; text-transform: uppercase; color: #9de8c7; font-size: 11px; margin-bottom: 10px;">Ready to play</div>
                        <h2 style="font-size: 22px; line-height: 1.2; margin-bottom: 10px; color: #f2f3ff;">Thread the neon maze</h2>
                        <p style="margin: 0 auto 18px; color: rgba(238, 241, 255, 0.78); line-height: 1.6; font-size: 13px;">Use Arrow keys or WASD to move. Eat food to grow, but don't hit the walls or yourself!</p>
                        <button class="action-btn" id="startBtn" style="padding: 14px 28px; font-family: 'Press Start 2P', monospace; font-size: 11px;">Start Game</button>
                        <div style="margin-top: 14px; display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; font-size: 12px;">
                            <span style="font-family: 'Press Start 2P', monospace; font-size: 10px; padding: 8px 10px; border-radius: 10px; border: 1px solid rgba(255, 255, 255, 0.16); background: rgba(0, 0, 0, 0.24); color: #e9edff;">Space</span>
                            <span style="font-family: 'Press Start 2P', monospace; font-size: 10px; padding: 8px 10px; border-radius: 10px; border: 1px solid rgba(255, 255, 255, 0.16); background: rgba(0, 0, 0, 0.24); color: #e9edff;">WASD</span>
                            <span style="font-family: 'Press Start 2P', monospace; font-size: 10px; padding: 8px 10px; border-radius: 10px; border: 1px solid rgba(255, 255, 255, 0.16); background: rgba(0, 0, 0, 0.24); color: #e9edff;">R</span>
                        </div>
                    </div>
                </div>
            </div>
            <div class="help-text">Use Arrow keys or WASD to move. Space to pause, R to restart.</div>
        </section>

        <aside class="glass-card sidebar">
            <div id="scoreboardMount"></div>
            <div class="eyebrow">Plan your run</div>
            <h2>Stay smooth, stay alive</h2>
            <ul class="tips">
                <li>Claim the perimeter early to avoid boxing yourself in later.</li>
                <li>Never reverse direction on instinct‚Äîsteer two moves ahead.</li>
                <li>Use pauses sparingly; the pace subtly ramps after each snack.</li>
            </ul>
            <div class="chip-row">
                <span class="chip">No wrap-around walls</span>
                <span class="chip">Local best saved per difficulty</span>
                <span class="chip">Instant restart</span>
            </div>
        </aside>
    </main>

    <div class="game-over-overlay" id="gameOverOverlay">
        <div class="game-over-content">
            <div class="game-over-header">
                <div class="game-over-icon" id="gameOverIcon">üíÄ</div>
                <div class="game-over-eyebrow" id="gameOverEyebrow">RUN ENDED</div>
                <h1 id="gameOverTitle">Game Over</h1>
                <p class="game-over-subtitle" id="gameOverSubtitle">You hit the wall</p>
            </div>
            
            <div class="game-over-stats">
                <div class="game-over-stats-grid">
                    <div class="game-over-stat highlight" id="scoreStatBox">
                        <div class="game-over-stat-value" id="finalScoreValue">0</div>
                        <div class="game-over-stat-label">Final Score</div>
                    </div>
                    <div class="game-over-stat" id="bestStatBox">
                        <div class="game-over-stat-value" id="finalBestValue">0</div>
                        <div class="game-over-stat-label">Best Score</div>
                    </div>
                    <div class="game-over-stat">
                        <div class="game-over-stat-value" id="finalLengthValue">0</div>
                        <div class="game-over-stat-label">Snake Length</div>
                    </div>
                    <div class="game-over-stat">
                        <div class="game-over-stat-value" id="finalPaceValue">--</div>
                        <div class="game-over-stat-label">Final Pace</div>
                    </div>
                    <div class="game-over-stat">
                        <div class="game-over-stat-value" id="finalFoodValue">0</div>
                        <div class="game-over-stat-label">Food Eaten</div>
                    </div>
                    <div class="game-over-stat">
                        <div class="game-over-stat-value" id="finalDiffValue">--</div>
                        <div class="game-over-stat-label">Difficulty</div>
                    </div>
                </div>
            </div>
            
            <div class="game-over-message" id="gameOverMessage">
                <div class="game-over-message-icon">üí°</div>
                <div class="game-over-message-text">
                    <div class="game-over-message-title" id="messageTitleEl">Keep practicing!</div>
                    <div class="game-over-message-desc" id="messageDescEl">Try claiming the perimeter early to avoid boxing yourself in.</div>
                </div>
            </div>
            
            <div class="game-over-progress" id="progressSection">
                <div class="game-over-progress-header">
                    <span class="game-over-progress-label">Progress to Best</span>
                    <span class="game-over-progress-value" id="progressPercent">0%</span>
                </div>
                <div class="game-over-progress-bar">
                    <div class="game-over-progress-fill" id="progressFill" style="width: 0%"></div>
                </div>
            </div>
            
            <div class="game-over-hints">
                <div class="game-over-hint"><kbd>Space</kbd> Play again</div>
                <div class="game-over-hint"><kbd>Esc</kbd> Back to menu</div>
            </div>
            
            <div class="game-over-buttons">
                <button class="game-over-btn primary" id="playAgain">Play Again</button>
                <button class="game-over-btn secondary" onclick="window.location.href='../games.html'">Back to Menu</button>
            </div>
        </div>
    </div>

    <script src="../sounds.js"></script>
    <script src="../scoreboard.js"></script>
    <script src="../themes.js"></script>
    <script src="../keybindings.js"></script>
    <script src="../achievements.js"></script>
    <script>
        const canvas = document.getElementById('board');
        const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });
        const scoreEl = document.getElementById('score');
        const bestEl = document.getElementById('best');
        const lengthEl = document.getElementById('length');
        const paceEl = document.getElementById('pace');
        const difficultyLabel = document.getElementById('difficultyLabel');
        const overlay = document.getElementById('gameOverOverlay');
        const finalScoreEl = document.getElementById('finalScore');
        const finalReasonEl = document.getElementById('finalReason');
        const playAgainBtn = document.getElementById('playAgain');
        const pauseBtn = document.getElementById('pauseBtn');
        const restartBtn = document.getElementById('restartBtn');
        const soundBtn = document.getElementById('soundBtn');

        // Initialize sound button
        soundBtn.textContent = soundEngine.isEnabled() ? 'üîä' : 'üîá';
        soundBtn.addEventListener('click', () => {
            soundEngine.init();
            soundEngine.toggle();
            soundBtn.textContent = soundEngine.isEnabled() ? 'üîä' : 'üîá';
            soundEngine.click();
        });

        const params = new URLSearchParams(window.location.search);
        const requestedDifficulty = (params.get('difficulty') || 'medium').toLowerCase();

        const DIFFICULTIES = {
            easy: { grid: 16, tick: 100, label: 'Easy' },
            medium: { grid: 18, tick: 75, label: 'Medium' },
            hard: { grid: 22, tick: 55, label: 'Hard' }
        };

        const difficultyKey = DIFFICULTIES[requestedDifficulty] ? requestedDifficulty : 'medium';
        const settings = DIFFICULTIES[requestedDifficulty] || DIFFICULTIES.medium;
        difficultyLabel.textContent = `${settings.label} ‚Ä¢ ${settings.grid} √ó ${settings.grid}`;

        const bestKey = `vanilla-snake-${settings.label.toLowerCase()}-best`;
        let bestScore = Number(localStorage.getItem(bestKey)) || 0;

        const scoreboard = window.VanillaScoreboard?.mount({
            mount: document.getElementById('scoreboardMount'),
            gameId: 'snake',
            difficulty: difficultyKey,
            bestKey,
            bestLabel: 'Personal best',
            scoreLabel: 'Score',
            formatScore: (value) => String(Math.floor(Number(value) || 0)),
            getSubmitScore: () => bestScore,
        });
        scoreboard?.setBest(bestScore);

        let snake = [];
        let food = null;
        const foodQueue = [];
        let direction = { x: 1, y: 0 };
        let queuedDirection = { x: 1, y: 0 };
        let score = 0;
        let tickInterval = settings.tick;
        let lastFrame = 0;
        let accumulator = 0;
        let state = 'idle'; // idle | running | paused | over
        let animationId = null;
        let cellSize = 20;
        let boardSize = 0;
        let dpr = 1;
        let prevSnake = [];
        let renderTime = 0;
        const foodPulsePhase = Math.random() * Math.PI * 2;

        function resizeCanvas() {
            const shell = canvas.parentElement;
            const shellStyles = window.getComputedStyle(shell);
            const paddingX = (Number.parseFloat(shellStyles.paddingLeft) || 0) + (Number.parseFloat(shellStyles.paddingRight) || 0);
            const availableWidth = Math.max(280, (shell.clientWidth || 640) - paddingX);
            const maxHeight = Math.max(320, window.innerHeight - 220);
            const rawSize = Math.min(Math.min(availableWidth, maxHeight), 740);
            boardSize = rawSize - (rawSize % settings.grid);

            dpr = Math.min(window.devicePixelRatio || 1, 2);
            canvas.style.width = `${boardSize}px`;
            canvas.style.height = `${boardSize}px`;
            canvas.width = Math.floor(boardSize * dpr);
            canvas.height = Math.floor(boardSize * dpr);

            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            ctx.imageSmoothingEnabled = true;
            cellSize = boardSize / settings.grid;
        }

        async function requestBackendFood() {
            try {
                const resp = await fetch('/api/snake/food', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ grid: settings.grid, snake })
                });
                if (!resp.ok) return;
                const data = await resp.json();
                if (typeof data.x === 'number' && typeof data.y === 'number') {
                    foodQueue.push({ x: data.x, y: data.y });
                }
            } catch (err) {
                console.warn('Snake backend food unavailable, using client RNG.', err);
            }
        }

        function placeFood() {
            const isOccupied = (candidate) => snake.some(segment => segment.x === candidate.x && segment.y === candidate.y);
            if (foodQueue.length > 0) {
                const candidate = foodQueue.shift();
                if (!isOccupied(candidate)) {
                    food = candidate;
                }
            }
            if (!food || isOccupied(food)) {
                let candidate;
                do {
                    candidate = {
                        x: Math.floor(Math.random() * settings.grid),
                        y: Math.floor(Math.random() * settings.grid)
                    };
                } while (isOccupied(candidate));
                food = candidate;
            }
            if (foodQueue.length < 2) requestBackendFood();
        }

        function resetGame() {
            overlay.classList.remove('active');
            score = 0;
            tickInterval = settings.tick;
            direction = { x: 1, y: 0 };
            queuedDirection = { x: 1, y: 0 };
            const center = Math.floor(settings.grid / 2);
            snake = [
                { x: center - 1, y: center },
                { x: center - 2, y: center },
                { x: center - 3, y: center }
            ];
            prevSnake = snake.map(segment => ({ ...segment }));
            placeFood();
            requestBackendFood();
            state = 'running';
            accumulator = 0;
            lastFrame = performance.now();
            updateHud();
        }

        function updateHud() {
            scoreEl.textContent = score;
            bestEl.textContent = bestScore;
            lengthEl.textContent = snake.length;
            paceEl.textContent = `${Math.round(1000 / tickInterval)} steps/s`;
        }

        function setDirection(newDirection) {
            const opposite = newDirection.x === -queuedDirection.x && newDirection.y === -queuedDirection.y;
            if (opposite) return;
            queuedDirection = newDirection;
        }

        function handleInput(event) {
            const key = event.key.toLowerCase();
            const directionMap = {
                arrowup: { x: 0, y: -1 },
                w: { x: 0, y: -1 },
                arrowdown: { x: 0, y: 1 },
                s: { x: 0, y: 1 },
                arrowleft: { x: -1, y: 0 },
                a: { x: -1, y: 0 },
                arrowright: { x: 1, y: 0 },
                d: { x: 1, y: 0 }
            };

            if (key === ' ') {
                event.preventDefault();
                togglePause();
                return;
            }

            if (key === 'r') {
                event.preventDefault();
                resetGame();
                return;
            }

            if (directionMap[key]) {
                event.preventDefault();
                setDirection(directionMap[key]);
            }
        }

        function togglePause() {
            if (state === 'over') return;
            const resuming = state === 'paused';
            state = resuming ? 'running' : 'paused';
            pauseBtn.textContent = state === 'paused' ? 'Resume' : 'Pause';
            accumulator = 0;
            prevSnake = snake.map(segment => ({ ...segment }));
            if (resuming) {
                lastFrame = performance.now();
            }
        }

        // Game over screen elements
        const gameOverIcon = document.getElementById('gameOverIcon');
        const gameOverEyebrow = document.getElementById('gameOverEyebrow');
        const gameOverTitle = document.getElementById('gameOverTitle');
        const gameOverSubtitle = document.getElementById('gameOverSubtitle');
        const finalScoreValue = document.getElementById('finalScoreValue');
        const finalBestValue = document.getElementById('finalBestValue');
        const finalLengthValue = document.getElementById('finalLengthValue');
        const finalPaceValue = document.getElementById('finalPaceValue');
        const finalFoodValue = document.getElementById('finalFoodValue');
        const finalDiffValue = document.getElementById('finalDiffValue');
        const scoreStatBox = document.getElementById('scoreStatBox');
        const bestStatBox = document.getElementById('bestStatBox');
        const messageTitleEl = document.getElementById('messageTitleEl');
        const messageDescEl = document.getElementById('messageDescEl');
        const progressPercent = document.getElementById('progressPercent');
        const progressFill = document.getElementById('progressFill');
        const progressSection = document.getElementById('progressSection');

        const tips = [
            { title: "Perimeter Strategy", desc: "Claim the edges early to give yourself escape routes later." },
            { title: "Think Two Moves Ahead", desc: "Don't reverse on instinct‚Äîplan your next two turns." },
            { title: "Pace Yourself", desc: "The game speeds up after each snack. Stay calm under pressure." },
            { title: "Corner Awareness", desc: "Avoid trapping yourself in corners when your snake gets long." },
            { title: "S-Pattern Movement", desc: "Moving in S-patterns helps cover the board efficiently." },
            { title: "Stay Central", desc: "Keep near the center for more escape options." }
        ];

        function getRandomTip() {
            return tips[Math.floor(Math.random() * tips.length)];
        }

        function endGame(reason) {
            state = 'over';
            const isNewRecord = score > bestScore;
            const foodEaten = Math.floor(score / 10);
            
            // Update best score if needed
            if (isNewRecord) {
                bestScore = score;
                localStorage.setItem(bestKey, bestScore);
                scoreboard?.setBest(bestScore);
            }
            
            // Configure overlay based on whether it's a new record
            if (isNewRecord && score > 0) {
                overlay.classList.add('victory');
                gameOverIcon.textContent = 'üèÜ';
                gameOverIcon.classList.add('victory');
                gameOverEyebrow.textContent = 'NEW HIGH SCORE!';
                gameOverEyebrow.classList.add('victory');
                gameOverTitle.textContent = 'Amazing Run!';
                scoreStatBox.classList.add('new-record');
                scoreStatBox.classList.remove('highlight');
            } else {
                overlay.classList.remove('victory');
                gameOverIcon.textContent = 'üíÄ';
                gameOverIcon.classList.remove('victory');
                gameOverEyebrow.textContent = 'RUN ENDED';
                gameOverEyebrow.classList.remove('victory');
                gameOverTitle.textContent = 'Game Over';
                scoreStatBox.classList.remove('new-record');
                scoreStatBox.classList.add('highlight');
            }
            
            // Set subtitle based on reason
            gameOverSubtitle.textContent = reason;
            
            // Populate stats
            finalScoreValue.textContent = score;
            finalBestValue.textContent = bestScore;
            finalLengthValue.textContent = snake.length;
            finalPaceValue.textContent = `${Math.round(1000 / tickInterval)}/s`;
            finalFoodValue.textContent = foodEaten;
            finalDiffValue.textContent = settings.label;
            
            // Show/update progress bar
            if (bestScore > 0 && !isNewRecord) {
                const progress = Math.min(100, Math.round((score / bestScore) * 100));
                progressPercent.textContent = `${progress}%`;
                progressFill.style.width = `${progress}%`;
                progressSection.style.display = 'block';
            } else if (isNewRecord) {
                progressPercent.textContent = '100%';
                progressFill.style.width = '100%';
                progressSection.style.display = 'block';
            } else {
                progressSection.style.display = 'none';
            }
            
            // Set tip message
            const tip = getRandomTip();
            messageTitleEl.textContent = tip.title;
            messageDescEl.textContent = tip.desc;
            
            // Show overlay
            overlay.classList.add('active');
            
            soundEngine.init();
            if (isNewRecord && score > 0) {
                soundEngine.victory();
            } else {
                soundEngine.gameOver();
            }
            
            updateHud();
        }
        
        // Handle keyboard shortcuts in game over screen
        document.addEventListener('keydown', (e) => {
            if (state === 'over') {
                if (e.key === ' ' || e.key === 'Enter') {
                    e.preventDefault();
                    resetGame();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    window.location.href = '../games.html';
                }
            }
        });

        function step() {
            prevSnake = snake.map(segment => ({ ...segment }));
            direction = queuedDirection;
            const head = snake[0];
            const next = { x: head.x + direction.x, y: head.y + direction.y };

            const outOfBounds =
                next.x < 0 || next.x >= settings.grid || next.y < 0 || next.y >= settings.grid;
            if (outOfBounds) {
                endGame('You hit the wall.');
                return;
            }

            const hitSelf = snake.some(seg => seg.x === next.x && seg.y === next.y);
            if (hitSelf) {
                endGame('You ran into yourself.');
                return;
            }

            snake.unshift(next);

            const ateFood = food && next.x === food.x && next.y === food.y;
            if (ateFood) {
                score += 10;
                tickInterval = Math.max(settings.tick * 0.35, tickInterval - 3);
                placeFood();
                soundEngine.init();
                soundEngine.coin();
                
                // Check score-based achievements
                if (window.VanillaAchievements) {
                    if (score >= 50) window.VanillaAchievements.unlock('snake_first_win');
                    if (score >= 100) window.VanillaAchievements.unlock('snake_centurion');
                    if (score >= 200) window.VanillaAchievements.unlock('snake_master');
                    if (score >= 100 && difficultyKey === 'hard') {
                        window.VanillaAchievements.unlock('snake_hard_win');
                    }
                }
            } else {
                snake.pop();
            }
            updateHud();
        }

        function draw() {
            const width = boardSize || canvas.width / dpr;
            const height = boardSize || canvas.height / dpr;
            const tickProgress = state === 'running' ? Math.min(1, accumulator / Math.max(1, tickInterval)) : 1;
            const lerp = (from, to, t) => from + (to - from) * t;
            const getInterpolatedSegment = (segment, index) => {
                if (!prevSnake || prevSnake.length === 0) return { x: segment.x, y: segment.y };
                const fallback = prevSnake[Math.max(0, prevSnake.length - 1)] || segment;
                const from = prevSnake[index] || fallback;
                return {
                    x: lerp(from.x, segment.x, tickProgress),
                    y: lerp(from.y, segment.y, tickProgress),
                };
            };

            ctx.clearRect(0, 0, width, height);

            const background = ctx.createLinearGradient(0, 0, width, height);
            background.addColorStop(0, '#0b1230');
            background.addColorStop(1, '#070a18');
            ctx.fillStyle = background;
            ctx.fillRect(0, 0, width, height);

            const vignette = ctx.createRadialGradient(width * 0.5, height * 0.45, width * 0.2, width * 0.5, height * 0.5, width * 0.75);
            vignette.addColorStop(0, 'rgba(16, 33, 84, 0.0)');
            vignette.addColorStop(1, 'rgba(0, 0, 0, 0.55)');
            ctx.fillStyle = vignette;
            ctx.fillRect(0, 0, width, height);

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.045)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= settings.grid; i++) {
                const offset = i * cellSize;
                ctx.beginPath();
                ctx.moveTo(offset, 0);
                ctx.lineTo(offset, height);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, offset);
                ctx.lineTo(width, offset);
                ctx.stroke();
            }

            if (food) {
                const fx = (food.x + 0.5) * cellSize;
                const fy = (food.y + 0.5) * cellSize;
                const pulse = 1 + 0.08 * Math.sin(renderTime / 180 + foodPulsePhase);
                const radius = cellSize * 0.34 * pulse;

                ctx.save();
                ctx.shadowColor = 'rgba(255, 107, 107, 0.6)';
                ctx.shadowBlur = cellSize * 0.7;

                const gradient = ctx.createRadialGradient(
                    fx - radius * 0.25,
                    fy - radius * 0.35,
                    radius * 0.15,
                    fx,
                    fy,
                    radius
                );
                gradient.addColorStop(0, '#fff3c4');
                gradient.addColorStop(0.55, '#ff6b6b');
                gradient.addColorStop(1, '#b43cff');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(fx, fy, radius, 0, Math.PI * 2);
                ctx.fill();

                ctx.shadowBlur = 0;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.18)';
                ctx.lineWidth = Math.max(1.2, cellSize * 0.05);
                ctx.beginPath();
                ctx.arc(fx, fy, radius * 0.98, 0, Math.PI * 2);
                ctx.stroke();

                ctx.fillStyle = 'rgba(255, 255, 255, 0.28)';
                ctx.beginPath();
                ctx.arc(fx - radius * 0.25, fy - radius * 0.25, radius * 0.22, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = 'rgba(157, 232, 199, 0.75)';
                ctx.lineWidth = Math.max(1.2, cellSize * 0.055);
                ctx.beginPath();
                ctx.ellipse(
                    fx + radius * 0.3,
                    fy - radius * 0.7,
                    radius * 0.28,
                    radius * 0.16,
                    -0.55,
                    0,
                    Math.PI * 2
                );
                ctx.stroke();
                ctx.restore();
            }

            if (snake.length > 0) {
                const points = snake.map((segment, index) => {
                    const interpolated = getInterpolatedSegment(segment, index);
                    return {
                        x: (interpolated.x + 0.5) * cellSize,
                        y: (interpolated.y + 0.5) * cellSize,
                    };
                });

                const head = points[0];
                const tail = points[points.length - 1];
                const bodyGradient = ctx.createLinearGradient(head.x, head.y, tail.x, tail.y);
                bodyGradient.addColorStop(0, '#9de8c7');
                bodyGradient.addColorStop(0.5, '#4ecdc4');
                bodyGradient.addColorStop(1, '#1da5b8');

                ctx.save();
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.strokeStyle = bodyGradient;
                ctx.lineWidth = cellSize * 0.78;
                ctx.shadowColor = 'rgba(78, 205, 196, 0.35)';
                ctx.shadowBlur = cellSize * 0.55;
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                ctx.stroke();

                ctx.shadowBlur = 0;
                ctx.globalAlpha = 0.55;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.25)';
                ctx.lineWidth = cellSize * 0.22;
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                ctx.stroke();
                ctx.restore();

                const headRadius = cellSize * 0.46;
                const headGradient = ctx.createRadialGradient(
                    head.x - headRadius * 0.35,
                    head.y - headRadius * 0.35,
                    headRadius * 0.2,
                    head.x,
                    head.y,
                    headRadius
                );
                headGradient.addColorStop(0, '#d4fff0');
                headGradient.addColorStop(0.5, '#6fe3cd');
                headGradient.addColorStop(1, '#1fb6a8');

                ctx.save();
                ctx.shadowColor = 'rgba(157, 232, 199, 0.45)';
                ctx.shadowBlur = cellSize * 0.65;
                ctx.fillStyle = headGradient;
                ctx.beginPath();
                ctx.arc(head.x, head.y, headRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.14)';
                ctx.lineWidth = Math.max(1.2, cellSize * 0.06);
                ctx.stroke();

                const dirLen = Math.hypot(direction.x, direction.y) || 1;
                const forward = { x: direction.x / dirLen, y: direction.y / dirLen };
                const side = { x: -forward.y, y: forward.x };
                const eyeForward = headRadius * 0.22;
                const eyeSide = headRadius * 0.28;
                const eyeRadius = headRadius * 0.12;

                const eyeA = {
                    x: head.x + forward.x * eyeForward + side.x * eyeSide,
                    y: head.y + forward.y * eyeForward + side.y * eyeSide,
                };
                const eyeB = {
                    x: head.x + forward.x * eyeForward - side.x * eyeSide,
                    y: head.y + forward.y * eyeForward - side.y * eyeSide,
                };

                ctx.fillStyle = 'rgba(8, 10, 22, 0.95)';
                [eyeA, eyeB].forEach((eye) => {
                    ctx.beginPath();
                    ctx.arc(eye.x, eye.y, eyeRadius, 0, Math.PI * 2);
                    ctx.fill();
                });

                ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
                const pupilRadius = eyeRadius * 0.38;
                const pupilOffset = eyeRadius * 0.35;
                [eyeA, eyeB].forEach((eye) => {
                    ctx.beginPath();
                    ctx.arc(
                        eye.x + forward.x * pupilOffset,
                        eye.y + forward.y * pupilOffset,
                        pupilRadius,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                });

                ctx.restore();
            }

            if (state === 'paused') {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.45)';
                ctx.fillRect(0, 0, width, height);
                ctx.fillStyle = '#f1f3ff';
                ctx.font = `bold ${Math.max(20, cellSize)}px Poppins`;
                ctx.textAlign = 'center';
                ctx.fillText('Paused', width / 2, height / 2);
            }
        }

        function loop(timestamp) {
            animationId = requestAnimationFrame(loop);
            if (lastFrame === 0) {
                lastFrame = timestamp;
            }
            const delta = timestamp - lastFrame;
            lastFrame = timestamp;
            renderTime = timestamp;

            if (state === 'running') {
                accumulator += delta;
                while (accumulator >= tickInterval) {
                    const interval = tickInterval;
                    step();
                    accumulator -= interval;
                    if (state === 'over') break;
                }
            }
            draw();
        }

        function startLoop() {
            if (animationId === null) {
                animationId = requestAnimationFrame(loop);
            }
        }

        pauseBtn.addEventListener('click', togglePause);
        restartBtn.addEventListener('click', resetGame);
        playAgainBtn.addEventListener('click', resetGame);
        document.addEventListener('keydown', handleInput);
        window.addEventListener('resize', () => {
            resizeCanvas();
            draw();
        });

        // Start overlay handling
        const startOverlay = document.getElementById('startOverlay');
        const startBtn = document.getElementById('startBtn');
        
        function showStartOverlay() {
            startOverlay.style.display = 'grid';
            state = 'idle';
        }
        
        function hideStartOverlay() {
            startOverlay.style.display = 'none';
        }
        
        function startGame() {
            hideStartOverlay();
            soundEngine.init();
            resetGame();
            // Track game played for achievements
            if (window.VanillaAchievements) {
                window.VanillaAchievements.trackGamePlayed('snake', difficultyKey);
            }
        }
        
        startBtn.addEventListener('click', startGame);

        resizeCanvas();
        // Don't auto-start - show overlay instead
        score = 0;
        tickInterval = settings.tick;
        const center = Math.floor(settings.grid / 2);
        snake = [
            { x: center - 1, y: center },
            { x: center - 2, y: center },
            { x: center - 3, y: center }
        ];
        prevSnake = snake.map(segment => ({ ...segment }));
        placeFood();
        updateHud();
        state = 'idle';
        startLoop();
    </script>
</body>
</html>
