<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Asteroids ‚Äî Play | VANILLA</title>
    <link rel="icon" type="image/svg+xml" href="../favicon.svg">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700;800&family=Press+Start+2P&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../styles.css">
    <link rel="stylesheet" href="../game-common.css">
</head>
<body class="game-page">
    <header>
        <div class="header-left">
            <a class="pill-link" href="../games.html">‚Üê Games</a>
            <span class="crumb">Asteroids</span>
            <span class="pill" id="difficultyLabel">Medium Sector</span>
        </div>
        <div class="header-actions">
            <button class="action-btn ghost" id="soundBtn">üîä</button>
            <button class="action-btn ghost fullscreen-btn" id="fullscreenBtn" title="Toggle Fullscreen">‚õ∂</button>
            <button class="action-btn ghost" id="pauseBtn">Pause</button>
            <button class="action-btn" id="restartBtn">Restart</button>
        </div>
    </header>

    <main>
        <section class="glass-card">
            <div class="hud">
                <div class="stat"><div class="label">Score</div><div class="value" id="scoreVal">0</div></div>
                <div class="stat"><div class="label">Best</div><div class="value" id="bestVal">0</div></div>
                <div class="stat"><div class="label">Lives</div><div class="value" id="livesVal">3</div></div>
                <div class="stat"><div class="label">Level</div><div class="value" id="levelVal">1</div></div>
            </div>
            <div class="board-shell canvas-shell" id="boardShell" style="--canvas-aspect-ratio: 4 / 3;">
                <canvas id="board"></canvas>
                <div class="canvas-overlay" id="startOverlay">
                    <div class="overlay-card">
                        <h1>‚òÑÔ∏è Asteroids</h1>
                        <p>Navigate through space and destroy asteroids. Watch out for debris!</p>
                        <div class="overlay-actions">
                            <button class="primary-btn" id="startBtn">START</button>
                        </div>
                        <div class="kbd-row">
                            <span><span class="kbd">‚Üê ‚Üí</span> Rotate</span>
                            <span><span class="kbd">‚Üë</span> Thrust</span>
                            <span><span class="kbd">Space</span> Fire</span>
                        </div>
                    </div>
                </div>
                <div class="canvas-overlay" id="pauseOverlay">
                    <div class="overlay-card">
                        <h1>‚è∏Ô∏è Paused</h1>
                        <p>Take a breather!</p>
                        <div class="overlay-actions">
                            <button class="primary-btn" id="resumeBtn">RESUME</button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="controls-hint">Rotate with ‚Üê/‚Üí. Thrust with ‚Üë. Space to fire.</div>
        </section>
        
        <aside class="glass-card sidebar">
            <div id="scoreboardMount"></div>
            <div class="eyebrow">Manage momentum</div>
            <h2>Survive the field</h2>
            <ul class="tips">
                <li>Thrust in short bursts‚Äîdon‚Äôt drift into debris.</li>
                <li>Clear small rocks first when crowded.</li>
                <li>Hyperspace is risky‚Äîuse it as a last resort.</li>
            </ul>
            <div class="chip-row">
                <span class="chip">Inertia physics</span>
                <span class="chip">Hyperspace</span>
                <span class="chip">Wave scaling</span>
            </div>
        </aside>
    </main>

    <div class="game-over-overlay" id="gameOverOverlay">
        <div class="game-over-content">
            <div class="game-over-header">
                <div class="game-over-icon">üíÄ</div>
                <div class="game-over-eyebrow">GAME OVER</div>
                <h1>Space Dust!</h1>
                <p class="game-over-subtitle">Your ship was destroyed.</p>
            </div>
            
            <div class="game-over-stats">
                <div class="game-over-stats-grid">
                    <div class="game-over-stat highlight">
                        <div class="game-over-stat-value" id="finalScore">0</div>
                        <div class="game-over-stat-label">Score</div>
                    </div>
                    <div class="game-over-stat" id="bestScoreStat">
                        <div class="game-over-stat-value" id="finalBest">0</div>
                        <div class="game-over-stat-label">Best</div>
                    </div>
                    <div class="game-over-stat">
                        <div class="game-over-stat-value" id="finalLevel">1</div>
                        <div class="game-over-stat-label">Level</div>
                    </div>
                </div>
            </div>
            
            <div class="game-over-buttons">
                <button class="game-over-btn primary" id="playAgainBtn">PLAY AGAIN</button>
                <a href="intro.html" class="game-over-btn secondary">Change Difficulty</a>
                <a href="../games.html" class="game-over-btn secondary">Back to Games</a>
            </div>
            
            <div class="game-over-hints">
                <div class="game-over-hint"><kbd>R</kbd> Restart</div>
                <div class="game-over-hint"><kbd>Enter</kbd> Play Again</div>
            </div>
        </div>
    </div>

    <script src="../engine.js"></script>
    <script src="../sounds.js"></script>
    <script src="../scoreboard.js"></script>
    <script src="../themes.js"></script>
    <script src="../keybindings.js"></script>
    <script src="../achievements.js"></script>
    <script>
        // ====================================================================
        // ASTEROIDS GAME
        // ====================================================================
        
        const canvas = document.getElementById('board');
        const ctx = canvas.getContext('2d');
        
        // Configuration based on difficulty
        const CONFIG = {
            easy: {
                label: 'Easy',
                shipSpeed: 0.15,
                rotationSpeed: 0.08,
                asteroidSpeed: 1,
                bulletSpeed: 8,
                startingAsteroids: 3,
                friction: 0.99,
                invulnerabilityTime: 3000
            },
            medium: {
                label: 'Medium',
                shipSpeed: 0.12,
                rotationSpeed: 0.07,
                asteroidSpeed: 1.5,
                bulletSpeed: 10,
                startingAsteroids: 4,
                friction: 0.995,
                invulnerabilityTime: 2000
            },
            hard: {
                label: 'Hard',
                shipSpeed: 0.1,
                rotationSpeed: 0.06,
                asteroidSpeed: 2,
                bulletSpeed: 12,
                startingAsteroids: 5,
                friction: 0.998,
                invulnerabilityTime: 1500
            }
        };
        
        // Get difficulty from URL
        const params = new URLSearchParams(window.location.search);
        const requestedDifficulty = (params.get('difficulty') || 'medium').toLowerCase();
        const difficultyKey = CONFIG[requestedDifficulty] ? requestedDifficulty : 'medium';
        const settings = CONFIG[difficultyKey];
        
        // Canvas size
        const WIDTH = 800;
        const HEIGHT = 600;
        
        // Game state
        let ship = null;
        let asteroids = [];
        let bullets = [];
        let particles = [];
        let score = 0;
        let lives = 3;
        let level = 1;
        const bestKey = `vanilla-asteroids-${difficultyKey}-best`;
        let bestScore = parseInt(localStorage.getItem(bestKey) || '0');
        let gameState = 'ready'; // ready, running, paused, over
        let lastTime = 0;
        let animationId = null;
        let keys = {};
        let invulnerableTimer = 0;
        
        // ================================================================
        // ENGINE UTILITIES (Optimized collision detection & memory)
        // ================================================================
        const { createSpatialHash, createObjectPool, createCleanupManager } = window.VanillaEngine;
        
        // Spatial hash for O(n) collision detection (cell size = largest asteroid)
        const spatialHash = createSpatialHash(80);
        
        // Object pool for particles (reduces GC pressure)
        const particlePool = createObjectPool(
            () => ({ x: 0, y: 0, vx: 0, vy: 0, life: 0, maxLife: 0 }),
            (p, x, y) => {
                p.x = x;
                p.y = y;
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 3;
                p.vx = Math.cos(angle) * speed;
                p.vy = Math.sin(angle) * speed;
                p.life = 30 + Math.random() * 30;
                p.maxLife = p.life;
            },
            50 // Pre-allocate 50 particles
        );
        
        // Cleanup manager for event listeners
        const cleanup = createCleanupManager();
        
        // DOM elements
        const difficultyLabel = document.getElementById('difficultyLabel');
        const scoreVal = document.getElementById('scoreVal');
        const bestVal = document.getElementById('bestVal');
        const livesVal = document.getElementById('livesVal');
        const levelVal = document.getElementById('levelVal');
        const startOverlay = document.getElementById('startOverlay');
        const pauseOverlay = document.getElementById('pauseOverlay');
        const gameOverOverlay = document.getElementById('gameOverOverlay');
        const startBtn = document.getElementById('startBtn');
        const resumeBtn = document.getElementById('resumeBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const restartBtn = document.getElementById('restartBtn');
        const playAgainBtn = document.getElementById('playAgainBtn');
        const soundBtn = document.getElementById('soundBtn');
        
        // Initialize displays
        bestVal.textContent = bestScore;
        if (difficultyLabel) {
            difficultyLabel.textContent = `${settings.label} Sector`;
        }

        const scoreboard = window.VanillaScoreboard?.mount({
            mount: document.getElementById('scoreboardMount'),
            gameId: 'asteroids',
            difficulty: difficultyKey,
            bestKey,
            bestLabel: 'Personal best',
            scoreLabel: 'Score',
            formatScore: (value) => String(Math.floor(Number(value) || 0)),
            getSubmitScore: () => bestScore,
        });
        scoreboard?.setBest(bestScore);
        
        // Resize canvas
        function resizeCanvas() {
            const maxWidth = Math.min(window.innerWidth - 40, 800);
            const scale = maxWidth / WIDTH;
            const width = WIDTH * scale;
            const height = HEIGHT * scale;
            
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            canvas.width = WIDTH;
            canvas.height = HEIGHT;
        }
        
        // Ship class
        class Ship {
            constructor() {
                this.x = WIDTH / 2;
                this.y = HEIGHT / 2;
                this.vx = 0;
                this.vy = 0;
                this.angle = -Math.PI / 2; // Pointing up
                this.radius = 15;
                this.thrusting = false;
            }
            
            update(delta) {
                // Rotation
                if (keys['ArrowLeft'] || keys['KeyA']) {
                    this.angle -= settings.rotationSpeed;
                }
                if (keys['ArrowRight'] || keys['KeyD']) {
                    this.angle += settings.rotationSpeed;
                }
                
                // Thrust
                this.thrusting = keys['ArrowUp'] || keys['KeyW'];
                if (this.thrusting) {
                    this.vx += Math.cos(this.angle) * settings.shipSpeed;
                    this.vy += Math.sin(this.angle) * settings.shipSpeed;
                }
                
                // Apply friction
                this.vx *= settings.friction;
                this.vy *= settings.friction;
                
                // Move
                this.x += this.vx;
                this.y += this.vy;
                
                // Wrap around screen
                if (this.x < 0) this.x = WIDTH;
                if (this.x > WIDTH) this.x = 0;
                if (this.y < 0) this.y = HEIGHT;
                if (this.y > HEIGHT) this.y = 0;
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle + Math.PI / 2);
                
                // Flash when invulnerable
                if (invulnerableTimer > 0 && Math.floor(Date.now() / 100) % 2) {
                    ctx.globalAlpha = 0.3;
                }
                
                // Ship body (triangle)
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, -this.radius);
                ctx.lineTo(-this.radius * 0.7, this.radius);
                ctx.lineTo(0, this.radius * 0.5);
                ctx.lineTo(this.radius * 0.7, this.radius);
                ctx.closePath();
                ctx.stroke();
                
                // Thrust flame
                if (this.thrusting) {
                    ctx.strokeStyle = '#ff6600';
                    ctx.beginPath();
                    ctx.moveTo(-this.radius * 0.3, this.radius);
                    ctx.lineTo(0, this.radius + 10 + Math.random() * 5);
                    ctx.lineTo(this.radius * 0.3, this.radius);
                    ctx.stroke();
                }
                
                ctx.restore();
            }
            
            reset() {
                this.x = WIDTH / 2;
                this.y = HEIGHT / 2;
                this.vx = 0;
                this.vy = 0;
                this.angle = -Math.PI / 2;
            }
        }
        
        // Asteroid class
        class Asteroid {
            constructor(x, y, size) {
                this.x = x || Math.random() * WIDTH;
                this.y = y || Math.random() * HEIGHT;
                this.size = size || 'large'; // large, medium, small
                
                // Set radius based on size
                switch (this.size) {
                    case 'large': this.radius = 40; this.points = 20; break;
                    case 'medium': this.radius = 25; this.points = 50; break;
                    case 'small': this.radius = 12; this.points = 100; break;
                }
                
                // Random velocity
                const speed = settings.asteroidSpeed * (this.size === 'small' ? 2 : this.size === 'medium' ? 1.5 : 1);
                const angle = Math.random() * Math.PI * 2;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                
                // Random rotation
                this.angle = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.05;
                
                // Generate random shape
                this.vertices = [];
                const numVertices = 8 + Math.floor(Math.random() * 5);
                for (let i = 0; i < numVertices; i++) {
                    const vertAngle = (i / numVertices) * Math.PI * 2;
                    const variation = 0.7 + Math.random() * 0.4;
                    this.vertices.push({
                        x: Math.cos(vertAngle) * this.radius * variation,
                        y: Math.sin(vertAngle) * this.radius * variation
                    });
                }
            }
            
            update(delta) {
                this.x += this.vx;
                this.y += this.vy;
                this.angle += this.rotationSpeed;
                
                // Wrap around screen
                if (this.x < -this.radius) this.x = WIDTH + this.radius;
                if (this.x > WIDTH + this.radius) this.x = -this.radius;
                if (this.y < -this.radius) this.y = HEIGHT + this.radius;
                if (this.y > HEIGHT + this.radius) this.y = -this.radius;
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                ctx.strokeStyle = '#aaaaaa';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.vertices[0].x, this.vertices[0].y);
                for (let i = 1; i < this.vertices.length; i++) {
                    ctx.lineTo(this.vertices[i].x, this.vertices[i].y);
                }
                ctx.closePath();
                ctx.stroke();
                
                ctx.restore();
            }
            
            split() {
                if (this.size === 'large') {
                    return [
                        new Asteroid(this.x, this.y, 'medium'),
                        new Asteroid(this.x, this.y, 'medium')
                    ];
                } else if (this.size === 'medium') {
                    return [
                        new Asteroid(this.x, this.y, 'small'),
                        new Asteroid(this.x, this.y, 'small')
                    ];
                }
                return [];
            }
        }
        
        // Bullet class
        class Bullet {
            constructor(x, y, angle) {
                this.x = x;
                this.y = y;
                this.vx = Math.cos(angle) * settings.bulletSpeed;
                this.vy = Math.sin(angle) * settings.bulletSpeed;
                this.radius = 2;
                this.life = 60; // frames
            }
            
            update(delta) {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
                
                // Wrap around screen
                if (this.x < 0) this.x = WIDTH;
                if (this.x > WIDTH) this.x = 0;
                if (this.y < 0) this.y = HEIGHT;
                if (this.y > HEIGHT) this.y = 0;
            }
            
            draw() {
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Particle class (for explosions)
        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 3;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 30 + Math.random() * 30;
                this.maxLife = this.life;
            }
            
            update(delta) {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.98;
                this.vy *= 0.98;
                this.life--;
            }
            
            draw() {
                const alpha = this.life / this.maxLife;
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Create explosion particles (using object pool)
        function createExplosion(x, y, count) {
            for (let i = 0; i < count; i++) {
                const p = particlePool.acquire(x, y);
                particles.push(p);
            }
        }
        
        // Initialize game
        function initGame() {
            ship = new Ship();
            asteroids = [];
            bullets = [];
            particles = [];
            
            // Create starting asteroids
            const numAsteroids = settings.startingAsteroids + (level - 1);
            for (let i = 0; i < numAsteroids; i++) {
                let x, y;
                // Spawn away from ship
                do {
                    x = Math.random() * WIDTH;
                    y = Math.random() * HEIGHT;
                } while (Math.hypot(x - ship.x, y - ship.y) < 150);
                
                asteroids.push(new Asteroid(x, y, 'large'));
            }
        }
        
        // Fire bullet
        function fireBullet() {
            if (bullets.length < 5) { // Max 5 bullets
                const tipX = ship.x + Math.cos(ship.angle) * ship.radius;
                const tipY = ship.y + Math.sin(ship.angle) * ship.radius;
                bullets.push(new Bullet(tipX, tipY, ship.angle));
                if (window.soundEngine) soundEngine.play('shoot');
            }
        }
        
        // Hyperspace (random teleport)
        function hyperspace() {
            ship.x = Math.random() * WIDTH;
            ship.y = Math.random() * HEIGHT;
            ship.vx = 0;
            ship.vy = 0;
            createExplosion(ship.x, ship.y, 10);
            if (window.soundEngine) soundEngine.play('jump');
        }
        
        // Check collision between two circles
        function checkCollision(obj1, obj2) {
            const dist = Math.hypot(obj1.x - obj2.x, obj1.y - obj2.y);
            return dist < obj1.radius + obj2.radius;
        }
        
        // Update game state
        function update(delta) {
            // Update invulnerability timer
            if (invulnerableTimer > 0) {
                invulnerableTimer -= delta;
            }
            
            // Update ship
            ship.update(delta);
            
            // Update asteroids
            for (const asteroid of asteroids) {
                asteroid.update(delta);
            }
            
            // Update bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                bullets[i].update(delta);
                if (bullets[i].life <= 0) {
                    bullets.splice(i, 1);
                }
            }
            
            // Update particles (with pool recycling)
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.98;
                p.vy *= 0.98;
                p.life--;
                if (p.life <= 0) {
                    particlePool.release(p); // Return to pool instead of GC
                    particles.splice(i, 1);
                }
            }
            
            // ================================================================
            // OPTIMIZED COLLISION DETECTION (O(n) using spatial hash)
            // ================================================================
            // Build spatial hash with asteroids for this frame
            spatialHash.clear();
            spatialHash.insertAll(asteroids);
            
            // Check bullet-asteroid collisions using spatial hash
            const bulletsToRemove = new Set();
            const asteroidsToRemove = new Set();
            const newAsteroidsToAdd = [];
            
            for (let i = 0; i < bullets.length; i++) {
                if (bulletsToRemove.has(i)) continue;
                const bullet = bullets[i];
                
                // Only check nearby asteroids (O(1) average instead of O(n))
                const nearby = spatialHash.getNearby(bullet);
                for (const asteroid of nearby) {
                    const asteroidIdx = asteroids.indexOf(asteroid);
                    if (asteroidIdx === -1 || asteroidsToRemove.has(asteroidIdx)) continue;
                    
                    if (checkCollision(bullet, asteroid)) {
                        // Add score
                        score += asteroid.points;
                        
                        // Create explosion
                        createExplosion(asteroid.x, asteroid.y, 15);
                        
                        // Split asteroid
                        newAsteroidsToAdd.push(...asteroid.split());
                        
                        // Mark for removal
                        asteroidsToRemove.add(asteroidIdx);
                        bulletsToRemove.add(i);
                        
                        if (window.soundEngine) soundEngine.play('coin');
                        break;
                    }
                }
            }
            
            // Apply removals (in reverse order to maintain indices)
            const sortedAsteroidIndices = [...asteroidsToRemove].sort((a, b) => b - a);
            for (const idx of sortedAsteroidIndices) {
                asteroids.splice(idx, 1);
            }
            const sortedBulletIndices = [...bulletsToRemove].sort((a, b) => b - a);
            for (const idx of sortedBulletIndices) {
                bullets.splice(idx, 1);
            }
            
            // Add new asteroids from splits
            asteroids.push(...newAsteroidsToAdd);
            
            if (bulletsToRemove.size > 0) {
                updateHUD();
            }
            
            // Check ship-asteroid collisions
            if (invulnerableTimer <= 0) {
                for (const asteroid of asteroids) {
                    if (checkCollision(ship, asteroid)) {
                        // Ship destroyed
                        lives--;
                        updateHUD();
                        createExplosion(ship.x, ship.y, 30);
                        
                        if (lives <= 0) {
                            gameOver();
                        } else {
                            ship.reset();
                            invulnerableTimer = settings.invulnerabilityTime;
                        }
                        
                        if (window.soundEngine) soundEngine.play('die');
                        break;
                    }
                }
            }
            
            // Check level complete
            if (asteroids.length === 0) {
                level++;
                updateHUD();
                initGame();
                invulnerableTimer = settings.invulnerabilityTime;
            }
        }
        
        // Render game
        function render() {
            // Clear canvas
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            
            // Draw stars (background)
            ctx.fillStyle = '#333333';
            for (let i = 0; i < 50; i++) {
                const x = (i * 97) % WIDTH;
                const y = (i * 53) % HEIGHT;
                ctx.fillRect(x, y, 1, 1);
            }
            
            // Draw particles (pooled objects - no draw method)
            for (const p of particles) {
                const alpha = p.life / p.maxLife;
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw asteroids
            for (const asteroid of asteroids) {
                asteroid.draw();
            }
            
            // Draw bullets
            for (const bullet of bullets) {
                bullet.draw();
            }
            
            // Draw ship
            ship.draw();
            
            // Draw lives indicator
            for (let i = 0; i < lives; i++) {
                ctx.save();
                ctx.translate(30 + i * 25, HEIGHT - 30);
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, -10);
                ctx.lineTo(-7, 10);
                ctx.lineTo(0, 5);
                ctx.lineTo(7, 10);
                ctx.closePath();
                ctx.stroke();
                ctx.restore();
            }
        }
        
        // Update HUD
        function updateHUD() {
            scoreVal.textContent = score;
            bestVal.textContent = bestScore;
            livesVal.textContent = lives;
            levelVal.textContent = level;
        }
        
        // Game loop
        function gameLoop(timestamp) {
            if (gameState !== 'running') {
                if (gameState !== 'over') {
                    animationId = requestAnimationFrame(gameLoop);
                }
                render(); // Still render when paused
                return;
            }
            
            const delta = timestamp - lastTime;
            lastTime = timestamp;
            
            update(delta);
            render();
            
            animationId = requestAnimationFrame(gameLoop);
        }
        
        // Game over
        function gameOver() {
            gameState = 'over';

            const isNewBest = score > bestScore;
            if (isNewBest) {
                bestScore = score;
                localStorage.setItem(bestKey, bestScore);
                updateHUD();
                scoreboard?.setBest(bestScore);
            }
            
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalBest').textContent = bestScore;
            document.getElementById('finalLevel').textContent = level;

            const bestStat = document.getElementById('bestScoreStat');
            if (bestStat) {
                bestStat.classList.toggle('new-record', isNewBest && score > 0);
            }
            
            gameOverOverlay.classList.add('active');
        }
        
        // Start game
        function startGame() {
            score = 0;
            lives = 3;
            level = 1;
            invulnerableTimer = settings.invulnerabilityTime;
            
            initGame();
            updateHUD();
            
            gameState = 'running';
            lastTime = performance.now();
            
            startOverlay.classList.remove('active');
            gameOverOverlay.classList.remove('active');
            
            if (!animationId) {
                animationId = requestAnimationFrame(gameLoop);
            }
        }
        
        // Restart game
        function restart() {
            gameOverOverlay.classList.remove('active');
            startGame();
        }
        
        // Toggle pause
        function togglePause() {
            if (gameState === 'running') {
                gameState = 'paused';
                pauseOverlay.classList.add('active');
                pauseBtn.textContent = 'Resume';
            } else if (gameState === 'paused') {
                gameState = 'running';
                pauseOverlay.classList.remove('active');
                pauseBtn.textContent = 'Pause';
                lastTime = performance.now();
            }
        }
        
        // Input handling
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            
            if (e.code === 'Space') {
                e.preventDefault();
                if (gameState === 'running') {
                    fireBullet();
                } else if (gameState === 'ready') {
                    startGame();
                } else if (gameState === 'over') {
                    restart();
                }
            }
            
            if (e.code === 'ShiftLeft' || e.code === 'ShiftRight' || e.code === 'KeyH') {
                e.preventDefault();
                if (gameState === 'running') {
                    hyperspace();
                }
            }
            
            if (e.code === 'KeyP') {
                e.preventDefault();
                togglePause();
            }
            
            if (e.code === 'KeyR') {
                e.preventDefault();
                restart();
            }
            
            if (e.code === 'Enter') {
                e.preventDefault();
                if (gameState === 'ready') {
                    startGame();
                } else if (gameState === 'over') {
                    restart();
                }
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });
        
        // Event listeners
        startBtn.onclick = startGame;
        resumeBtn.onclick = togglePause;
        pauseBtn.onclick = togglePause;
        restartBtn.onclick = restart;
        playAgainBtn.onclick = restart;
        
        // Sound toggle
        soundBtn.onclick = () => {
            if (window.soundEngine) {
                soundEngine.toggle();
                soundBtn.textContent = soundEngine.enabled ? 'üîä' : 'üîá';
            }
        };
        
        // Fullscreen toggle
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const boardShell = document.getElementById('boardShell');
        
        function toggleFullscreen() {
            if (!document.fullscreenElement && !document.webkitFullscreenElement) {
                if (boardShell.requestFullscreen) {
                    boardShell.requestFullscreen();
                } else if (boardShell.webkitRequestFullscreen) {
                    boardShell.webkitRequestFullscreen();
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                }
            }
        }
        
        fullscreenBtn.onclick = toggleFullscreen;
        
        document.addEventListener('fullscreenchange', () => {
            resizeCanvas();
        });
        document.addEventListener('webkitfullscreenchange', () => {
            resizeCanvas();
        });
        
        // F key for fullscreen
        document.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'f' && !e.ctrlKey && !e.metaKey) {
                e.preventDefault();
                toggleFullscreen();
            }
        });
        
        // Initialize
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Show start overlay
        startOverlay.classList.add('active');
        
        // Initial draw
        ship = new Ship();
        asteroids = [];
        for (let i = 0; i < 3; i++) {
            asteroids.push(new Asteroid());
        }
        render();
        
        // Start the loop (paused initially)
        animationId = requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
