<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flappy Bird ‚Äî Play | VANILLA</title>
    <link rel="icon" type="image/svg+xml" href="../favicon.svg">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700;800&family=Press+Start+2P&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../styles.css">
    <link rel="stylesheet" href="../game-common.css">
</head>
<body class="game-page">
    <header>
        <div class="header-left">
            <a class="pill-link" href="../games.html">‚Üê Games</a>
            <span class="crumb">Flappy Bird</span>
            <span class="pill" id="difficultyLabel">Medium Flight</span>
        </div>
        <div class="header-actions">
            <button class="action-btn ghost" id="soundBtn">üîä</button>
            <button class="action-btn ghost fullscreen-btn" id="fullscreenBtn" title="Toggle Fullscreen">‚õ∂</button>
            <button class="action-btn ghost" id="pauseBtn">Pause</button>
            <button class="action-btn" id="restartBtn">Restart</button>
        </div>
    </header>

    <main>
        <section class="glass-card">
            <div class="hud">
                <div class="stat"><div class="label">Score</div><div class="value" id="scoreVal">0</div></div>
                <div class="stat"><div class="label">Best</div><div class="value" id="bestVal">0</div></div>
            </div>
            <div class="board-shell canvas-shell" id="boardShell" style="--canvas-aspect-ratio: 9 / 16;">
                <canvas id="board"></canvas>
                <div class="canvas-overlay" id="startOverlay">
                    <div class="overlay-card">
                        <h1>üê¶ Flappy Bird</h1>
                        <p>Tap or press Space to flap your wings and navigate through the pipes!</p>
                        <div class="overlay-actions">
                            <button class="primary-btn" id="startBtn">START</button>
                        </div>
                        <div class="kbd-row">
                            <span><span class="kbd">Space</span> Flap</span>
                            <span><span class="kbd">P</span> Pause</span>
                        </div>
                    </div>
                </div>
                <div class="canvas-overlay" id="pauseOverlay">
                    <div class="overlay-card">
                        <h1>‚è∏Ô∏è Paused</h1>
                        <p>Take a breather!</p>
                        <div class="overlay-actions">
                            <button class="primary-btn" id="resumeBtn">RESUME</button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="controls-hint">Space / Click to flap. P to pause.</div>
        </section>
        
        <aside class="glass-card sidebar">
            <div id="scoreboardMount"></div>
            <div class="eyebrow">Find the rhythm</div>
            <h2>Thread the pipes</h2>
            <ul class="tips">
                <li>Tap in short bursts‚Äîavoid long holds.</li>
                <li>Focus on the next gap, not the bird.</li>
                <li>Center your line before each opening.</li>
            </ul>
            <div class="chip-row">
                <span class="chip">One-button control</span>
                <span class="chip">Endless runner</span>
                <span class="chip">Quick restart</span>
            </div>
        </aside>
    </main>

    <div class="game-over-overlay" id="gameOverOverlay">
        <div class="game-over-content">
            <div class="game-over-header">
                <div class="game-over-icon">üíÄ</div>
                <div class="game-over-eyebrow">GAME OVER</div>
                <h1>Keep Trying!</h1>
                <p class="game-over-subtitle">Every pipe is a lesson learned.</p>
            </div>
            
            <div class="game-over-stats">
                <div class="game-over-stats-grid">
                    <div class="game-over-stat highlight">
                        <div class="game-over-stat-value" id="finalScore">0</div>
                        <div class="game-over-stat-label">Score</div>
                    </div>
                    <div class="game-over-stat" id="bestScoreStat">
                        <div class="game-over-stat-value" id="finalBest">0</div>
                        <div class="game-over-stat-label">Best</div>
                    </div>
                    <div class="game-over-stat">
                        <div class="game-over-stat-value" id="finalDifficulty">Medium</div>
                        <div class="game-over-stat-label">Difficulty</div>
                    </div>
                </div>
            </div>
            
            <div class="game-over-buttons">
                <button class="game-over-btn primary" id="playAgainBtn">PLAY AGAIN</button>
                <a href="intro.html" class="game-over-btn secondary">Change Difficulty</a>
                <a href="../games.html" class="game-over-btn secondary">Back to Games</a>
            </div>
            
            <div class="game-over-hints">
                <div class="game-over-hint"><kbd>R</kbd> Restart</div>
                <div class="game-over-hint"><kbd>Enter</kbd> Play Again</div>
            </div>
        </div>
    </div>

    <script src="../sounds.js"></script>
    <script src="../scoreboard.js"></script>
    <script src="../engine.js"></script>
    <script>
        // ====================================================================
        // FLAPPY BIRD GAME
        // ====================================================================
        
        // Use VanillaEngine utilities
        const engine_createGameEngine = VanillaEngine.createGameEngine;
        const engine_createInputManager = VanillaEngine.createInputManager;
        const FlappyCanvasUtils = VanillaEngine.CanvasUtils;
        const FlappyCollision = VanillaEngine.Collision;
        const FlappyMathUtils = VanillaEngine.MathUtils;
        const FlappyStorage = VanillaEngine.Storage;
        
        // Configuration
        const CONFIG = {
            easy: {
                label: 'Easy',
                gravity: 0.35,
                flapStrength: -7,
                pipeSpeed: 2.5,
                pipeGap: 180,
                pipeSpacing: 280,
                pipeWidth: 70
            },
            medium: {
                label: 'Medium',
                gravity: 0.45,
                flapStrength: -8,
                pipeSpeed: 3.5,
                pipeGap: 150,
                pipeSpacing: 250,
                pipeWidth: 65
            },
            hard: {
                label: 'Hard',
                gravity: 0.55,
                flapStrength: -9,
                pipeSpeed: 4.5,
                pipeGap: 120,
                pipeSpacing: 220,
                pipeWidth: 60
            }
        };
        
        // Get difficulty from URL
        const params = new URLSearchParams(window.location.search);
        const requestedDifficulty = (params.get('difficulty') || 'medium').toLowerCase();
        const difficultyKey = CONFIG[requestedDifficulty] ? requestedDifficulty : 'medium';
        const settings = CONFIG[difficultyKey];
        
        // Game state
        let bird = null;
        let pipes = [];
        let score = 0;
        let bestScore = FlappyStorage.getHighScore('flappy', difficultyKey);
        let gameStarted = false;
        let groundY = 0;
        let skyGradient = null;
        
        // Bird constants
        const BIRD_SIZE = 30;
        const BIRD_X = 100;
        
        // DOM elements
        const canvas = document.getElementById('board');
        const scoreVal = document.getElementById('scoreVal');
        const bestVal = document.getElementById('bestVal');
        const difficultyLabel = document.getElementById('difficultyLabel');
        const startOverlay = document.getElementById('startOverlay');
        const pauseOverlay = document.getElementById('pauseOverlay');
        const gameOverOverlay = document.getElementById('gameOverOverlay');
        const startBtn = document.getElementById('startBtn');
        const resumeBtn = document.getElementById('resumeBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const restartBtn = document.getElementById('restartBtn');
        const playAgainBtn = document.getElementById('playAgainBtn');
        const soundBtn = document.getElementById('soundBtn');
        
        // Initialize displays
        if (difficultyLabel) {
            difficultyLabel.textContent = `${settings.label} Flight`;
        }
        bestVal.textContent = bestScore;

        const bestKey = `vanilla-flappy-${difficultyKey}-best`;
        const scoreboard = window.VanillaScoreboard?.mount({
            mount: document.getElementById('scoreboardMount'),
            gameId: 'flappy',
            difficulty: difficultyKey,
            bestKey,
            bestLabel: 'Personal best',
            scoreLabel: 'Score',
            formatScore: (value) => String(Math.floor(Number(value) || 0)),
            getSubmitScore: () => bestScore,
        });
        scoreboard?.setBest(bestScore);
        
        // Initialize input
        const input = engine_createInputManager();
        input.init();
        
        // Create game engine
        const engine = engine_createGameEngine({
            canvas,
            targetFPS: 120,
            onUpdate: update,
            onRender: render,
            onStateChange: handleStateChange,
            onResize: handleResize
        });
        
        // Initialize bird
        function initBird(canvasHeight) {
            bird = {
                x: BIRD_X,
                y: canvasHeight / 2,
                velocity: 0,
                rotation: 0,
                flapFrame: 0
            };
        }
        
        // Initialize game
        function initGame() {
            groundY = engine.height - 80;
            initBird(engine.height);
            pipes = [];
            score = 0;
            gameStarted = false;
            updateHUD();
            
            // Create sky gradient
            const ctx = engine.ctx;
            skyGradient = ctx.createLinearGradient(0, 0, 0, engine.height);
            skyGradient.addColorStop(0, '#1a2a4a');
            skyGradient.addColorStop(0.5, '#2a3a5a');
            skyGradient.addColorStop(1, '#1a3040');
        }

        // Difficulty ramps slightly with score for a more "alive" endless run.
        function getTuning() {
            const pace = Math.min(1, score / 50);
            return {
                pipeSpeed: settings.pipeSpeed * (1 + pace * 0.35),
                pipeGap: Math.max(95, settings.pipeGap * (1 - pace * 0.22)),
                pipeSpacing: settings.pipeSpacing * (1 - pace * 0.12),
            };
        }
        
        // Spawn a new pipe
        function spawnPipe() {
            const tuning = getTuning();
            const minGapY = 100;
            const maxGapY = Math.max(minGapY, groundY - tuning.pipeGap - 100);
            const gapY = FlappyMathUtils.random(minGapY, maxGapY);
            
            pipes.push({
                x: engine.width + settings.pipeWidth,
                gapY: gapY,
                gapSize: tuning.pipeGap,
                scored: false
            });
        }
        
        // Flap the bird
        function flap() {
            if (engine.getState() !== 'running') return;
            
            if (!gameStarted) {
                gameStarted = true;
                if (pipes.length === 0) spawnPipe();
            }
            
            bird.velocity = settings.flapStrength;
            bird.flapFrame = 10;
            
            if (window.soundEngine) {
                soundEngine.play('jump');
            }
        }
        
        // Update game state
        function update(tickScale) {
            if (!bird || !gameStarted) return;

            const tuning = getTuning();
            
            // Apply gravity
            bird.velocity += settings.gravity * tickScale;
            bird.y += bird.velocity * tickScale;
            
            // Update rotation based on velocity
            bird.rotation = FlappyMathUtils.clamp(bird.velocity * 3, -30, 90);
            
            // Update flap animation
            if (bird.flapFrame > 0) {
                bird.flapFrame--;
            }
            
            // Check ground collision
            if (bird.y + BIRD_SIZE / 2 >= groundY) {
                bird.y = groundY - BIRD_SIZE / 2;
                gameOver();
                return;
            }
            
            // Check ceiling collision
            if (bird.y - BIRD_SIZE / 2 <= 0) {
                bird.y = BIRD_SIZE / 2;
                bird.velocity = 0;
            }
            
            // Update pipes
            for (let i = pipes.length - 1; i >= 0; i--) {
                const pipe = pipes[i];
                pipe.x -= tuning.pipeSpeed * tickScale;
                
                // Remove off-screen pipes
                if (pipe.x + settings.pipeWidth < 0) {
                    pipes.splice(i, 1);
                    continue;
                }
                
                // Check collision with pipes
                const birdRect = {
                    x: bird.x - BIRD_SIZE / 2 + 5,
                    y: bird.y - BIRD_SIZE / 2 + 5,
                    width: BIRD_SIZE - 10,
                    height: BIRD_SIZE - 10
                };
                
                // Top pipe
                const topPipe = {
                    x: pipe.x,
                    y: 0,
                    width: settings.pipeWidth,
                    height: pipe.gapY
                };
                
                // Bottom pipe
                const bottomPipe = {
                    x: pipe.x,
                    y: pipe.gapY + pipe.gapSize,
                    width: settings.pipeWidth,
                    height: engine.height - pipe.gapY - pipe.gapSize
                };
                
                if (FlappyCollision.rectRect(birdRect, topPipe) || FlappyCollision.rectRect(birdRect, bottomPipe)) {
                    gameOver();
                    return;
                }
                
                // Score if passed pipe
                if (!pipe.scored && pipe.x + settings.pipeWidth < bird.x) {
                    pipe.scored = true;
                    score++;
                    updateHUD();
                    
                    if (window.soundEngine) {
                        soundEngine.play('score');
                    }
                    
                    // Check achievements
                    checkAchievements();
                }
            }
            
            // Spawn new pipes
            const lastPipe = pipes[pipes.length - 1];
            if (!lastPipe || lastPipe.x < engine.width - tuning.pipeSpacing) {
                spawnPipe();
            }
        }
        
        // Check achievements
        function checkAchievements() {
            if (window.VanillaAchievements) {
                if (score >= 1) VanillaAchievements.unlock('flappy_first_pipe');
                if (score >= 10) VanillaAchievements.unlock('flappy_10_pipes');
                if (score >= 25) VanillaAchievements.unlock('flappy_25_pipes');
                if (score >= 50) VanillaAchievements.unlock('flappy_50_pipes');
            }
        }
        
        // Render game
        function render(ctx, width, height) {
            // Draw sky
            ctx.fillStyle = skyGradient || '#1a2a4a';
            ctx.fillRect(0, 0, width, height);
            
            // Draw stars
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            for (let i = 0; i < 50; i++) {
                const x = (i * 73) % width;
                const y = (i * 47) % (height * 0.6);
                const size = (i % 3) + 1;
                ctx.fillRect(x, y, size, size);
            }
            
            // Draw clouds
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            drawCloud(ctx, 100, 80, 60);
            drawCloud(ctx, 300, 120, 80);
            drawCloud(ctx, 550, 60, 50);
            drawCloud(ctx, 750, 140, 70);
            
            // Draw pipes
            for (const pipe of pipes) {
                drawPipe(ctx, pipe);
            }
            
            // Draw ground
            ctx.fillStyle = '#2a4a3a';
            ctx.fillRect(0, groundY, width, height - groundY);
            
            // Ground detail line
            ctx.fillStyle = '#3a5a4a';
            ctx.fillRect(0, groundY, width, 4);
            
            // Draw grass tufts
            ctx.fillStyle = '#4a7a5a';
            for (let x = 0; x < width; x += 20) {
                ctx.beginPath();
                ctx.moveTo(x, groundY);
                ctx.lineTo(x + 5, groundY - 8);
                ctx.lineTo(x + 10, groundY);
                ctx.fill();
            }
            
            // Draw bird
            if (bird) {
                drawBird(ctx, bird);
            }
            
            // Draw score in center if playing
            if (gameStarted && engine.getState() === 'running') {
                ctx.font = 'bold 48px Poppins';
                ctx.textAlign = 'center';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 10;
                ctx.fillText(score, width / 2, 80);
                ctx.shadowBlur = 0;
            }
            
            // Draw "tap to start" if not started
            if (!gameStarted && engine.getState() === 'running') {
                ctx.font = 'bold 20px Poppins';
                ctx.textAlign = 'center';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.fillText('Tap or Press Space to Start', width / 2, height / 2 + 80);
            }
        }
        
        // Draw a cloud
        function drawCloud(ctx, x, y, size) {
            ctx.beginPath();
            ctx.arc(x, y, size * 0.5, 0, Math.PI * 2);
            ctx.arc(x + size * 0.4, y - size * 0.2, size * 0.4, 0, Math.PI * 2);
            ctx.arc(x + size * 0.8, y, size * 0.45, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Draw a pipe
        function drawPipe(ctx, pipe) {
            const { x, gapY } = pipe;
            const pipeWidth = settings.pipeWidth;
            const capHeight = 30;
            const capOverhang = 6;
            
            // Pipe colors
            const pipeColor = '#3a8a4a';
            const pipeDark = '#2a6a3a';
            const pipeLight = '#4aaa5a';
            const capColor = '#3a9a4a';
            
            // Top pipe body
            ctx.fillStyle = pipeColor;
            ctx.fillRect(x, 0, pipeWidth, gapY - capHeight);
            
            // Top pipe highlight
            ctx.fillStyle = pipeLight;
            ctx.fillRect(x + 5, 0, 8, gapY - capHeight);
            
            // Top pipe shadow
            ctx.fillStyle = pipeDark;
            ctx.fillRect(x + pipeWidth - 10, 0, 10, gapY - capHeight);
            
            // Top pipe cap
            ctx.fillStyle = capColor;
            ctx.fillRect(x - capOverhang, gapY - capHeight, pipeWidth + capOverhang * 2, capHeight);
            
            // Top cap highlight
            ctx.fillStyle = pipeLight;
            ctx.fillRect(x - capOverhang + 3, gapY - capHeight + 3, 10, capHeight - 6);
            
            // Bottom pipe body
            const bottomY = gapY + pipe.gapSize;
            ctx.fillStyle = pipeColor;
            ctx.fillRect(x, bottomY + capHeight, pipeWidth, engine.height - bottomY - capHeight);
            
            // Bottom pipe highlight
            ctx.fillStyle = pipeLight;
            ctx.fillRect(x + 5, bottomY + capHeight, 8, engine.height - bottomY - capHeight);
            
            // Bottom pipe shadow
            ctx.fillStyle = pipeDark;
            ctx.fillRect(x + pipeWidth - 10, bottomY + capHeight, 10, engine.height - bottomY - capHeight);
            
            // Bottom pipe cap
            ctx.fillStyle = capColor;
            ctx.fillRect(x - capOverhang, bottomY, pipeWidth + capOverhang * 2, capHeight);
            
            // Bottom cap highlight
            ctx.fillStyle = pipeLight;
            ctx.fillRect(x - capOverhang + 3, bottomY + 3, 10, capHeight - 6);
        }
        
        // Draw the bird
        function drawBird(ctx, bird) {
            ctx.save();
            ctx.translate(bird.x, bird.y);
            ctx.rotate(bird.rotation * Math.PI / 180);
            
            const size = BIRD_SIZE;
            const flapping = bird.flapFrame > 5;
            
            // Body
            ctx.fillStyle = '#f4d03f';
            ctx.beginPath();
            ctx.ellipse(0, 0, size / 2, size / 2.5, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Belly
            ctx.fillStyle = '#f5e6ab';
            ctx.beginPath();
            ctx.ellipse(2, 3, size / 3.5, size / 4, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Wing
            ctx.fillStyle = '#e67e22';
            ctx.beginPath();
            if (flapping) {
                ctx.ellipse(-5, -8, 8, 5, -0.3, 0, Math.PI * 2);
            } else {
                ctx.ellipse(-5, 2, 8, 5, 0.3, 0, Math.PI * 2);
            }
            ctx.fill();
            
            // Eye white
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(8, -5, 7, 0, Math.PI * 2);
            ctx.fill();
            
            // Eye black
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(10, -5, 3, 0, Math.PI * 2);
            ctx.fill();
            
            // Eye highlight
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(11, -6, 1.5, 0, Math.PI * 2);
            ctx.fill();
            
            // Beak
            ctx.fillStyle = '#e74c3c';
            ctx.beginPath();
            ctx.moveTo(12, 0);
            ctx.lineTo(22, 2);
            ctx.lineTo(12, 5);
            ctx.closePath();
            ctx.fill();
            
            // Beak line
            ctx.strokeStyle = '#c0392b';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(12, 2);
            ctx.lineTo(18, 2);
            ctx.stroke();
            
            ctx.restore();
        }
        
        // Update HUD
        function updateHUD() {
            scoreVal.textContent = score;
            bestVal.textContent = bestScore;
        }
        
        // Game over
        function gameOver() {
            engine.setState('over');
            
            if (window.soundEngine) {
                soundEngine.play('die');
            }
            
            // Check for new best
            const isNewBest = FlappyStorage.setHighScore('flappy', difficultyKey, score);
            if (isNewBest) {
                bestScore = score;
                updateHUD();
                scoreboard?.setBest(bestScore);
                
                if (window.VanillaAchievements) {
                    VanillaAchievements.trackHighScore('flappy');
                }
            }
            
            // Track game played
            if (window.VanillaAchievements) {
                VanillaAchievements.trackGamePlayed('flappy', difficultyKey);
            }
            
            // Update game over screen
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalBest').textContent = bestScore;
            document.getElementById('finalDifficulty').textContent = settings.label;
            
            const bestStat = document.getElementById('bestScoreStat');
            if (isNewBest && score > 0) {
                bestStat.classList.add('new-record');
            } else {
                bestStat.classList.remove('new-record');
            }
            
            gameOverOverlay.classList.add('active');
        }
        
        // Handle state changes
        function handleStateChange(newState, oldState) {
            startOverlay.classList.toggle('active', newState === 'ready');
            pauseOverlay.classList.toggle('active', newState === 'paused');
            
            if (newState === 'running' && oldState === 'ready') {
                initGame();
            }
        }
        
        // Handle resize
        function handleResize(width, height) {
            groundY = height - 80;
            if (bird && bird.y > groundY - BIRD_SIZE) {
                bird.y = groundY - BIRD_SIZE;
            }
        }
        
        // Restart game
        function restart({ autoplay = true } = {}) {
            gameOverOverlay.classList.remove('active');
            initGame();
            engine.setState('running');
            if (autoplay) {
                flap();
            }
        }

        function startRun() {
            const state = engine.getState();
            if (state === 'ready') {
                engine.setState('running');
            }
            if (engine.getState() !== 'running') return;
            flap();
        }
        
        // Event listeners
        startBtn.onclick = startRun;
        resumeBtn.onclick = () => engine.setState('running');
        pauseBtn.onclick = () => engine.togglePause();
        restartBtn.onclick = () => restart({ autoplay: true });
        playAgainBtn.onclick = () => restart({ autoplay: true });
        
        // Canvas pointer to start/flap (works for mouse + touch)
        canvas.addEventListener('pointerdown', (e) => {
            e.preventDefault();
            startRun();
        }, { passive: false });
        
        // Keyboard controls
        input.onKey(' ', startRun);
        input.onKey('w', startRun);
        input.onKey('arrowup', startRun);
        
        input.onKey('p', () => {
            if (engine.getState() === 'running') {
                engine.setState('paused');
            } else if (engine.getState() === 'paused') {
                engine.setState('running');
            }
        });
        
        input.onKey('r', () => {
            if (engine.getState() === 'over') {
                restart();
            }
        });
        
        input.onKey('enter', () => {
            if (engine.getState() === 'over') {
                restart({ autoplay: true });
            } else if (engine.getState() === 'ready') {
                startRun();
            }
        });
        
        input.onKey('escape', () => {
            if (engine.getState() === 'running') {
                engine.setState('paused');
            }
        });
        
        // Sound toggle
        soundBtn.onclick = () => {
            if (window.soundEngine) {
                soundEngine.toggle();
                soundBtn.textContent = soundEngine.enabled ? 'üîä' : 'üîá';
                
                if (window.VanillaAchievements) {
                    VanillaAchievements.trackSoundToggle();
                }
            }
        };
        
        // Fullscreen toggle
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const boardShell = document.getElementById('boardShell');
        
        function toggleFullscreen() {
            if (!document.fullscreenElement && !document.webkitFullscreenElement) {
                if (boardShell.requestFullscreen) {
                    boardShell.requestFullscreen();
                } else if (boardShell.webkitRequestFullscreen) {
                    boardShell.webkitRequestFullscreen();
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                }
            }
        }
        
        fullscreenBtn.onclick = toggleFullscreen;
        
        document.addEventListener('fullscreenchange', () => {
            engine.resize({ aspectRatio: 9/16, maxWidth: 400, maxHeight: 700 });
        });
        document.addEventListener('webkitfullscreenchange', () => {
            engine.resize({ aspectRatio: 9/16, maxWidth: 400, maxHeight: 700 });
        });
        
        // F key for fullscreen
        input.onKey('f', () => {
            toggleFullscreen();
        });
        
        // Start engine
        engine.resize({ aspectRatio: 9/16, maxWidth: 400, maxHeight: 700 });
        engine.start();
        startOverlay.classList.add('active');
        
        // Handle window resize
        window.addEventListener('resize', () => {
            engine.resize({ aspectRatio: 9/16, maxWidth: 400, maxHeight: 700 });
        });
    </script>
</body>
</html>
