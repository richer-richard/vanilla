<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Shooters ‚Äî Play | VANILLA</title>
    <link rel="icon" type="image/svg+xml" href="../favicon.svg">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700;800&family=Press+Start+2P&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../styles.css">
    <style>
        body { min-height: 100vh; }

        header {
            padding: 16px 28px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: linear-gradient(90deg, rgba(102, 126, 234, 0.12), rgba(118, 75, 162, 0.1));
            border-bottom: 1px solid rgba(102, 126, 234, 0.3);
            position: sticky;
            top: 0;
            z-index: 5;
        }

        .header-left { display: flex; align-items: center; gap: 12px; }
        .crumb { color: #cdd2f1; letter-spacing: 0.6px; font-size: 12px; }
        .pill { padding: 10px 14px; border-radius: 12px; border: 1px solid rgba(102, 126, 234, 0.4); background: rgba(102, 126, 234, 0.12); color: #dfe4ff; font-weight: 700; font-size: 12px; letter-spacing: 0.4px; }
        .pill-link { text-decoration: none; color: #dfe4ff; border: 1px solid rgba(102, 126, 234, 0.4); padding: 10px 12px; border-radius: 10px; background: rgba(255, 255, 255, 0.04); font-family: 'Press Start 2P', monospace; font-size: 10px; letter-spacing: 0.8px; transition: all 0.2s ease; }
        .pill-link:hover { transform: translateY(-2px); box-shadow: 0 10px 24px rgba(0, 0, 0, 0.35); border-color: rgba(118, 75, 162, 0.75); }
        .header-actions { display: flex; gap: 10px; }
        .action-btn { padding: 10px 14px; border-radius: 12px; border: 1px solid rgba(255, 255, 255, 0.15); background: linear-gradient(135deg, rgba(102, 126, 234, 0.24), rgba(118, 75, 162, 0.2)); color: #f2f4ff; font-weight: 700; letter-spacing: 0.3px; cursor: pointer; transition: all 0.2s ease; }
        .action-btn.ghost { background: rgba(255, 255, 255, 0.06); border-color: rgba(255, 255, 255, 0.1); }
        .action-btn:hover { transform: translateY(-2px); box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35); }

        main {
            width: min(1200px, 100%);
            margin: 0 auto;
            padding: 26px 24px 60px;
            display: grid;
            grid-template-columns: minmax(0, 2.2fr) minmax(0, 1fr);
            gap: 18px;
            align-items: start;
        }
        @media (max-width: 980px) { main { grid-template-columns: 1fr; } }

        .glass-card {
            background: linear-gradient(150deg, rgba(255, 255, 255, 0.02), rgba(102, 126, 234, 0.08));
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            box-shadow: 0 25px 70px rgba(0, 0, 0, 0.35), 0 10px 22px rgba(102, 126, 234, 0.1);
            padding: 18px;
            position: relative;
            overflow: hidden;
        }
        .glass-card::after {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 12% 18%, rgba(118, 75, 162, 0.16), transparent 32%),
                        radial-gradient(circle at 82% 8%, rgba(102, 126, 234, 0.14), transparent 30%);
            pointer-events: none;
        }
        .glass-card > * { position: relative; z-index: 1; }

        .hud {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
            gap: 10px;
            margin-bottom: 12px;
        }
        @media (max-width: 860px) { .hud { grid-template-columns: repeat(3, minmax(0, 1fr)); } }

        .stat {
            padding: 12px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            background: rgba(255, 255, 255, 0.03);
            min-height: 56px;
        }
        .stat .label { font-size: 11px; color: #adb6da; letter-spacing: 0.6px; text-transform: uppercase; }
        .stat .value { font-size: 18px; font-weight: 800; margin-top: 4px; }

        .stage {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .canvas-shell {
            position: relative;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            background: radial-gradient(circle at 20% 20%, rgba(102, 126, 234, 0.18), transparent 35%),
                        radial-gradient(circle at 80% 10%, rgba(118, 75, 162, 0.18), transparent 30%),
                        rgba(6, 9, 25, 0.9);
            padding: 12px;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: auto;
            aspect-ratio: 16 / 9;
            display: block;
            background: #050913;
            border-radius: 12px;
            touch-action: none;
        }

        .canvas-overlay {
            position: absolute;
            inset: 12px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            background: rgba(0, 0, 0, 0.45);
            backdrop-filter: blur(8px);
            transition: opacity 0.2s ease, transform 0.2s ease;
        }
        /* (visibility handled by shared .canvas-overlay/.active styles in styles.css) */

        .overlay-card {
            width: min(520px, 92%);
            padding: 18px 18px 16px;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.16), rgba(118, 75, 162, 0.14));
            box-shadow: 0 30px 70px rgba(0, 0, 0, 0.55);
        }
        .eyebrow { letter-spacing: 1.8px; text-transform: uppercase; color: #9fb0ff; font-size: 11px; margin-bottom: 10px; }
        .overlay-card h1 { margin: 0 0 10px; font-size: 24px; line-height: 1.2; }
        .overlay-card p { margin: 0 0 14px; color: #d7dcf3; line-height: 1.6; font-size: 13px; }

        .overlay-actions { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-top: 6px; }
        .primary-btn {
            padding: 12px 16px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: linear-gradient(135deg, rgba(110, 231, 255, 0.22), rgba(102, 126, 234, 0.22));
            color: #f2f4ff;
            font-weight: 800;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            letter-spacing: 0.9px;
        }
        .primary-btn:hover { transform: translateY(-2px); box-shadow: 0 10px 30px rgba(0, 0, 0, 0.45); }
        .secondary-btn {
            padding: 12px 16px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: rgba(255, 255, 255, 0.06);
            color: #f2f4ff;
            font-weight: 800;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            letter-spacing: 0.9px;
        }
        .secondary-btn:hover { transform: translateY(-2px); box-shadow: 0 10px 30px rgba(0, 0, 0, 0.45); }

        .kbd-row { margin-top: 12px; display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; color: rgba(255, 255, 255, 0.82); font-size: 12px; }
        .kbd {
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            padding: 8px 10px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.16);
            background: rgba(0, 0, 0, 0.24);
            color: #e9edff;
        }

        .sidebar h2 { margin: 6px 0 12px; font-size: 20px; }
        .tips { list-style: none; padding-left: 0; display: flex; flex-direction: column; gap: 10px; color: #cbd0ea; }
        .tips li { padding: 10px 12px; border-radius: 12px; border: 1px solid rgba(255, 255, 255, 0.08); background: rgba(255, 255, 255, 0.03); }

        .badge-row { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 14px; }
        .chip { padding: 8px 12px; border-radius: 10px; border: 1px solid rgba(102, 126, 234, 0.35); background: rgba(102, 126, 234, 0.08); color: #dfe4ff; font-weight: 700; font-size: 12px; }
        .chip.rapid { border-color: rgba(251, 113, 133, 0.5); background: rgba(251, 113, 133, 0.12); }
        .chip.multi { border-color: rgba(250, 204, 21, 0.5); background: rgba(250, 204, 21, 0.12); }

        /* Make the global overlay feel closer to this page */
        .game-over-content h1 { color: #ff7aa2; }
        .game-over-btn { font-family: 'Press Start 2P', monospace; font-size: 11px; letter-spacing: 0.8px; }
    </style>
</head>
<body>
    <header>
        <div class="header-left">
            <a class="pill-link" href="../games.html">‚Üê Games</a>
            <span class="crumb">Space Shooters</span>
            <span class="pill" id="difficultyLabel">Medium</span>
        </div>
        <div class="header-actions">
            <button class="action-btn ghost" id="soundBtn">üîä</button>
            <button class="action-btn ghost fullscreen-btn" id="fullscreenBtn" title="Toggle Fullscreen">‚õ∂</button>
            <button class="action-btn ghost" id="pauseBtn" type="button">Pause</button>
            <button class="action-btn" id="restartBtn" type="button">Restart</button>
        </div>
    </header>

    <main>
        <section class="glass-card stage">
            <div class="hud">
                <div class="stat"><div class="label">Score</div><div class="value" id="score">0</div></div>
                <div class="stat"><div class="label">Best</div><div class="value" id="best">0</div></div>
                <div class="stat"><div class="label">Wave</div><div class="value" id="wave">1</div></div>
                <div class="stat"><div class="label">Hull</div><div class="value" id="hull">100%</div></div>
                <div class="stat"><div class="label">Shields</div><div class="value" id="shields">3</div></div>
                <div class="stat"><div class="label">Weapon</div><div class="value" id="weapon">Normal</div></div>
                <div class="stat"><div class="label">Autofire</div><div class="value" id="autofire">Off</div></div>
            </div>

            <div class="canvas-shell">
                <canvas id="board" width="960" height="540" aria-label="Space Shooters game canvas"></canvas>
                <div class="canvas-overlay active" id="startOverlay">
                    <div class="overlay-card">
                        <div class="eyebrow">Mission Brief</div>
                        <h1>Enemies shoot back.</h1>
                        <p>Move, dodge bullet lanes, and grab buds for <b>Rapid</b> fire and <b>Multi</b> shot.</p>
                        <div class="overlay-actions">
                            <button class="primary-btn" id="startBtn" type="button">Start</button>
                            <button class="secondary-btn" id="focusBtn" type="button">Focus Canvas</button>
                        </div>
                        <div class="kbd-row">
                            <span class="kbd">A/D</span>
                            <span class="kbd">‚Üê/‚Üí</span>
                            <span class="kbd">Space</span>
                            <span class="kbd">Shift</span>
                            <span class="kbd">P</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="badge-row">
                <span class="chip rapid">Rapid Bud = faster fire</span>
                <span class="chip multi">Multi Bud = triple shot</span>
                <span class="chip">Enemies fire constantly</span>
            </div>
        </section>

        <aside class="glass-card sidebar">
            <div id="scoreboardMount"></div>
            <div class="eyebrow">Stay nimble</div>
            <h2>How to survive</h2>
            <ul class="tips">
                <li>Hold <b>Shift</b> to toggle autofire (good for dense waves).</li>
                <li>Grab a <b>Rapid</b> bud to boost firing speed for a short time.</li>
                <li>Grab a <b>Multi</b> bud to shoot three paths at once.</li>
                <li>Don‚Äôt tunnel-vision‚Äîwatch the yellow enemy bullets.</li>
            </ul>
            <div class="badge-row">
                <span class="chip">Tap Space to start</span>
                <span class="chip">Click/touch to steer</span>
                <span class="chip">P to pause</span>
            </div>
        </aside>
    </main>

    <div class="game-over-overlay" id="gameOverOverlay">
        <div class="game-over-content">
            <div class="game-over-header">
                <div class="game-over-icon" id="gameOverIcon">üöÄ</div>
                <div class="game-over-eyebrow" id="gameOverEyebrow">MISSION FAILED</div>
                <h1 id="gameOverTitle">Ship Destroyed</h1>
                <p class="game-over-subtitle" id="gameOverSubtitle">Your shields were depleted</p>
            </div>
            
            <div class="game-over-stats">
                <div class="game-over-stats-grid">
                    <div class="game-over-stat highlight" id="scoreStatBox">
                        <div class="game-over-stat-value" id="finalScoreValue">0</div>
                        <div class="game-over-stat-label">Final Score</div>
                    </div>
                    <div class="game-over-stat" id="bestStatBox">
                        <div class="game-over-stat-value" id="finalBestValue">0</div>
                        <div class="game-over-stat-label">Best Score</div>
                    </div>
                    <div class="game-over-stat">
                        <div class="game-over-stat-value" id="finalWaveValue">1</div>
                        <div class="game-over-stat-label">Wave Reached</div>
                    </div>
                    <div class="game-over-stat">
                        <div class="game-over-stat-value" id="finalKillsValue">0</div>
                        <div class="game-over-stat-label">Enemies Killed</div>
                    </div>
                    <div class="game-over-stat">
                        <div class="game-over-stat-value" id="finalShieldsValue">0</div>
                        <div class="game-over-stat-label">Shields Used</div>
                    </div>
                    <div class="game-over-stat">
                        <div class="game-over-stat-value" id="finalPowerupsValue">0</div>
                        <div class="game-over-stat-label">Powerups</div>
                    </div>
                    <div class="game-over-stat">
                        <div class="game-over-stat-value" id="finalDiffValue">--</div>
                        <div class="game-over-stat-label">Difficulty</div>
                    </div>
                </div>
            </div>
            
            <div class="game-over-message" id="gameOverMessage">
                <div class="game-over-message-icon">üí°</div>
                <div class="game-over-message-text">
                    <div class="game-over-message-title" id="messageTitleEl">Stay mobile</div>
                    <div class="game-over-message-desc" id="messageDescEl">Keep moving to dodge enemy fire and grab powerups.</div>
                </div>
            </div>
            
            <div class="game-over-progress" id="progressSection" style="display:none;">
                <div class="game-over-progress-header">
                    <span class="game-over-progress-label">Mission Progress</span>
                    <span class="game-over-progress-value" id="progressPercent">0%</span>
                </div>
                <div class="game-over-progress-bar">
                    <div class="game-over-progress-fill" id="progressFill" style="width: 0%"></div>
                </div>
            </div>
            
            <div class="game-over-hints">
                <div class="game-over-hint"><kbd>Space</kbd> Play again</div>
                <div class="game-over-hint"><kbd>Esc</kbd> Back to menu</div>
            </div>
            
            <div class="game-over-buttons">
                <button class="game-over-btn primary" id="playAgain" type="button">Play Again</button>
                <button class="game-over-btn secondary" type="button" onclick="window.location.href='../games.html'">Back to Menu</button>
            </div>
        </div>
    </div>

    <script src="../engine.js"></script>
    <script src="../sounds.js"></script>
    <script src="../scoreboard.js"></script>
    <script src="../themes.js"></script>
    <script src="../keybindings.js"></script>
    <script src="../achievements.js"></script>
    <script>
        // ================================================================
        // ENGINE UTILITIES (Optimized collision detection & memory)
        // ================================================================
        const { createSpatialHash, createObjectPool, createCleanupManager } = window.VanillaEngine;
        
        // Spatial hash for O(n) collision detection (cell size = enemy width)
        const spatialHash = createSpatialHash(50);
        
        // Object pool for particles (reduces GC pressure)
        const particlePool = createObjectPool(
            () => ({ x: 0, y: 0, vx: 0, vy: 0, life: 0, size: 0, color: '' }),
            (p, x, y, color) => {
                p.x = x;
                p.y = y;
                const ang = Math.random() * Math.PI * 2;
                const sp = 60 + Math.random() * 180;
                p.vx = Math.cos(ang) * sp;
                p.vy = Math.sin(ang) * sp;
                p.life = 0.35 + Math.random() * 0.4;
                p.size = 1.2 + Math.random() * 1.8;
                p.color = color || 'rgba(110,231,255,0.9)';
            },
            100 // Pre-allocate 100 particles
        );
        
        // Cleanup manager for event listeners
        const cleanup = createCleanupManager();

        const canvas = document.getElementById('board');
        const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });

        const scoreEl = document.getElementById('score');
        const bestEl = document.getElementById('best');
        const waveEl = document.getElementById('wave');
        const hullEl = document.getElementById('hull');
        const shieldsEl = document.getElementById('shields');
        const weaponEl = document.getElementById('weapon');
        const autofireEl = document.getElementById('autofire');
        const difficultyLabel = document.getElementById('difficultyLabel');
        const startOverlay = document.getElementById('startOverlay');
        const startBtn = document.getElementById('startBtn');
        const focusBtn = document.getElementById('focusBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const restartBtn = document.getElementById('restartBtn');

        const gameOverOverlay = document.getElementById('gameOverOverlay');
        const finalScoreEl = document.getElementById('finalScore');
        const finalReasonEl = document.getElementById('finalReason');
        const playAgainBtn = document.getElementById('playAgain');

        const params = new URLSearchParams(window.location.search);
        const requestedDifficulty = (params.get('difficulty') || 'medium').toLowerCase();

        const CONFIG = {
            easy:   { label: 'Easy',   lives: 4, playerSpeed: 360, playerFireCd: 0.22, enemySpeed: 130, enemyFireBase: 1.65, enemyBulletSpeed: 300, bulletDamage: 16 },
            medium: { label: 'Medium', lives: 3, playerSpeed: 400, playerFireCd: 0.24, enemySpeed: 155, enemyFireBase: 1.35, enemyBulletSpeed: 340, bulletDamage: 20 },
            hard:   { label: 'Hard',   lives: 3, playerSpeed: 430, playerFireCd: 0.26, enemySpeed: 175, enemyFireBase: 1.10, enemyBulletSpeed: 380, bulletDamage: 24 },
        };
        const settings = CONFIG[requestedDifficulty] || CONFIG.medium;
        const difficultyKey = CONFIG[requestedDifficulty] ? requestedDifficulty : 'medium';
        difficultyLabel.textContent = `${settings.label} ‚Ä¢ ${settings.lives} shields`;

        const bestKey = `vanilla-space_shooters-${difficultyKey}-best`;
        let bestScore = Number(localStorage.getItem(bestKey)) || 0;
        bestEl.textContent = String(bestScore);

        const scoreboard = window.VanillaScoreboard?.mount({
            mount: document.getElementById('scoreboardMount'),
            gameId: 'space_shooters',
            difficulty: difficultyKey,
            bestKey,
            bestLabel: 'Personal best',
            scoreLabel: 'Score',
            formatScore: (value) => String(Math.floor(Number(value) || 0)),
            getSubmitScore: () => bestScore,
        });
        scoreboard?.setBest(bestScore);

        const TARGET_FPS = 120;
        const STEP = 1 / TARGET_FPS;
	        const MAX_FRAME_DT = 0.05;
	        const MAX_STEPS_PER_FRAME = Math.ceil(MAX_FRAME_DT / STEP);

	        const WORLD = { w: canvas.width, h: canvas.height };

	        function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
	        function rand(min, max) { return min + Math.random() * (max - min); }

	        let bgGradient = null;
	        let hazeGradient = null;
	        function rebuildBackgroundGradients() {
	            bgGradient = ctx.createLinearGradient(0, 0, 0, WORLD.h);
	            bgGradient.addColorStop(0, '#0c132b');
	            bgGradient.addColorStop(1, '#060a18');

	            hazeGradient = ctx.createRadialGradient(WORLD.w * 0.25, WORLD.h * 0.2, 20, WORLD.w * 0.25, WORLD.h * 0.2, WORLD.w * 0.7);
	            hazeGradient.addColorStop(0, 'rgba(118, 75, 162, 0.18)');
	            hazeGradient.addColorStop(1, 'rgba(0,0,0,0)');
	        }
	        rebuildBackgroundGradients();

        function drawRoundRect(x, y, w, h, r) {
            const radius = Math.max(0, Math.min(r, Math.min(w, h) / 2));
            if (ctx.roundRect) {
                ctx.beginPath();
                ctx.roundRect(x, y, w, h, radius);
                return;
            }
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + w - radius, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
            ctx.lineTo(x + w, y + h - radius);
            ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
            ctx.lineTo(x + radius, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
        }

        function pointerToWorldX(clientX) {
            const rect = canvas.getBoundingClientRect();
            const t = (clientX - rect.left) / Math.max(1, rect.width);
            return clamp(t * WORLD.w, 0, WORLD.w);
        }

        const keys = Object.create(null);
        const input = {
            pointerActive: false,
            pointerX: WORLD.w / 2,
            fireHeld: false,
        };

        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            // Prevent default for game control keys to stop page scrolling
            if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', ' '].includes(e.key.toLowerCase()) || e.key === ' ') {
                e.preventDefault();
            }

            if (e.key === ' ') {
                input.fireHeld = true;
                if (game.state === 'ready') startGame();
            }
            if (e.key.toLowerCase() === 'shift') {
                if (game.state !== 'over') {
                    game.player.autofire = !game.player.autofire;
                    updateHud();
                }
            }
            if (e.key.toLowerCase() === 'p') togglePause();
            if (e.key.toLowerCase() === 'r') resetGame();
        });
        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            if (e.key === ' ') input.fireHeld = false;
        });

        canvas.addEventListener('pointerdown', (e) => {
            canvas.setPointerCapture(e.pointerId);
            input.pointerActive = true;
            input.pointerX = pointerToWorldX(e.clientX);
            input.fireHeld = true;
            if (game.state === 'ready') startGame();
        });
        canvas.addEventListener('pointermove', (e) => {
            if (!input.pointerActive) return;
            input.pointerX = pointerToWorldX(e.clientX);
        });
        canvas.addEventListener('pointerup', () => {
            input.pointerActive = false;
            input.fireHeld = false;
        });
        canvas.addEventListener('pointercancel', () => {
            input.pointerActive = false;
            input.fireHeld = false;
        });

        function normalizePowerType(type) {
            const t = String(type || '').toLowerCase();
            if (t === 'rapid') return 'rapid';
            if (t === 'double' || t === 'multi' || t === 'triple') return 'multi';
            if (t === 'shield' || t === 'life') return 'shield';
            return null;
        }

        function initStars() {
            const stars = [];
            const layers = [
                { count: 60, speed: 40, size: 1.2, alpha: 0.35 },
                { count: 45, speed: 70, size: 1.6, alpha: 0.55 },
                { count: 26, speed: 110, size: 2.2, alpha: 0.75 },
            ];
            for (const layer of layers) {
                for (let i = 0; i < layer.count; i++) {
                    stars.push({
                        x: Math.random() * WORLD.w,
                        y: Math.random() * WORLD.h,
                        speed: layer.speed * (0.7 + Math.random() * 0.7),
                        size: layer.size * (0.8 + Math.random() * 0.8),
                        alpha: layer.alpha,
                    });
                }
            }
            return stars;
        }

        const wavePlans = new Map();

        async function requestWavePlan(waveNum) {
            try {
                const resp = await fetch('/api/space/wave', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        wave: waveNum,
                        difficulty: requestedDifficulty,
                        width: WORLD.w,
                        height: WORLD.h,
                    }),
                });
                if (!resp.ok) return;
                const data = await resp.json();
                if (!data || !Array.isArray(data.enemies)) return;
                wavePlans.set(waveNum, data);
            } catch (err) {
                // Offline / file:// mode is supported via local plan.
            }
        }

        function localWavePlan(waveNum) {
            const count = clamp(4 + Math.floor(waveNum * 0.9), 4, 10);
            const enemies = [];
            for (let i = 0; i < count; i++) {
                const roll = Math.random();
                let kind = 'drone';
                let hp = 1;
                let pattern = 'straight';
                if (roll > 0.82) { kind = 'bomber'; hp = 2; pattern = 'sway'; }
                else if (roll > 0.62) { kind = 'zig'; hp = 2; pattern = 'zigzag'; }
                else if (roll > 0.38) { kind = 'slicer'; hp = 1; pattern = 'strafe'; }
                enemies.push({
                    kind,
                    pattern,
                    hp,
                    x: rand(44, WORLD.w - 44),
                    y: -rand(40, 220),
                    w: 34,
                    h: 24,
                    speed: settings.enemySpeed + rand(0, 55) + waveNum * 3,
                    phase: rand(0, Math.PI * 2),
                });
            }

            const powerups = [];
            if (Math.random() < 0.58) {
                const type = waveNum % 4 === 0 ? 'shield' : (Math.random() < 0.5 ? 'rapid' : 'double');
                powerups.push({ type, delay: rand(0.55, 1.55), x: WORLD.w * rand(0.25, 0.75) });
            }
            return { wave: waveNum, enemies, powerups };
        }

        function createPlayer() {
            return {
                x: WORLD.w / 2,
                y: WORLD.h - 68,
                w: 44,
                h: 28,
                speed: settings.playerSpeed,
                maxHp: 100,
                hp: 100,
                lives: settings.lives,
                invuln: 0,
                baseFireCd: settings.playerFireCd,
                fireTimer: 0,
                autofire: false,
                rapidTimer: 0,
                multiTimer: 0,
            };
        }

        const game = {
            state: 'ready', // ready | running | paused | over
            lastTime: 0,
            accumulator: 0,
            score: 0,
            wave: 0,
            stars: initStars(),
            player: createPlayer(),
            enemies: [],
            bullets: [],
            enemyBullets: [],
            powerups: [],
            particles: [],
            scheduledDrops: [],
            nextWaveTimer: 0,
        };

        function resetEntities() {
            game.stars = initStars();
            game.player = createPlayer();
            game.enemies = [];
            game.bullets = [];
            game.enemyBullets = [];
            game.powerups = [];
            game.particles = [];
            game.scheduledDrops = [];
            game.nextWaveTimer = 0;
            wavePlans.clear();
            requestWavePlan(1);
            requestWavePlan(2);
        }

	        function resetGame() {
	            gameOverOverlay.classList.remove('active');
	            game.state = 'ready';
	            game.lastTime = 0;
	            game.accumulator = 0;
	            game.score = 0;
	            game.wave = 0;
	            totalKills = 0;
	            totalShieldsUsed = 0;
	            totalPowerups = 0;
	            input.fireHeld = false;
	            input.pointerActive = false;
	            startOverlay.classList.add('active');
	            pauseBtn.textContent = 'Pause';
	            resetEntities();
            updateHud();
        }

        function startGame() {
            if (game.state === 'over') return;
            if (game.state === 'paused') return;
            if (game.state === 'running') return;
            game.state = 'running';
            startOverlay.classList.remove('active');
            spawnWave(1);
            updateHud();
        }

        function togglePause() {
            if (game.state === 'over') return;
            if (game.state === 'ready') return;
            game.state = game.state === 'paused' ? 'running' : 'paused';
            pauseBtn.textContent = game.state === 'paused' ? 'Resume' : 'Pause';
        }

        // Game over screen elements
        const gameOverIcon = document.getElementById('gameOverIcon');
        const gameOverEyebrow = document.getElementById('gameOverEyebrow');
        const gameOverTitle = document.getElementById('gameOverTitle');
        const gameOverSubtitle = document.getElementById('gameOverSubtitle');
        const finalScoreValue = document.getElementById('finalScoreValue');
        const finalBestValue = document.getElementById('finalBestValue');
        const finalWaveValue = document.getElementById('finalWaveValue');
        const finalKillsValue = document.getElementById('finalKillsValue');
        const finalShieldsValue = document.getElementById('finalShieldsValue');
        const finalPowerupsValue = document.getElementById('finalPowerupsValue');
        const finalDiffValue = document.getElementById('finalDiffValue');
        const scoreStatBox = document.getElementById('scoreStatBox');
        const messageTitleEl = document.getElementById('messageTitleEl');
        const messageDescEl = document.getElementById('messageDescEl');

        let totalKills = 0;
        let totalShieldsUsed = 0;
        let totalPowerups = 0;

        const tips = [
            { title: "Stay Mobile", desc: "Keep moving to dodge enemy fire and grab powerups." },
            { title: "Autofire Advantage", desc: "Use Shift to toggle autofire during heavy waves." },
            { title: "Powerup Priority", desc: "Grab Multi buds for wave clears, Rapid for bosses." },
            { title: "Watch the Lanes", desc: "Track yellow enemy bullets‚Äîthey're your biggest threat." },
            { title: "Edge Safety", desc: "Use screen edges to limit enemy approach angles." },
            { title: "Multi-Shot Timing", desc: "Triple shots are best against spread formations." }
        ];

        function getRandomTip() {
            return tips[Math.floor(Math.random() * tips.length)];
        }

        function endGame(reason) {
            game.state = 'over';

            if (game.score > bestScore) {
                bestScore = game.score;
                localStorage.setItem(bestKey, String(bestScore));
                bestEl.textContent = String(bestScore);
                scoreboard?.setBest(bestScore);
            }
            
            // Configure overlay
            gameOverIcon.textContent = 'üí•';
            gameOverEyebrow.textContent = 'MISSION FAILED';
            gameOverTitle.textContent = 'Ship Destroyed';
            gameOverSubtitle.textContent = reason || 'Your shields were depleted';
            
            // Populate stats
            finalScoreValue.textContent = game.score;
            finalBestValue.textContent = bestScore;
            finalWaveValue.textContent = game.wave;
            finalKillsValue.textContent = totalKills;
            finalShieldsValue.textContent = totalShieldsUsed;
            finalPowerupsValue.textContent = totalPowerups;
            finalDiffValue.textContent = settings.label;
            
            // Set tip message
            const tip = getRandomTip();
            messageTitleEl.textContent = tip.title;
            messageDescEl.textContent = tip.desc;
            
            // Show overlay
            gameOverOverlay.classList.add('active');
            
            soundEngine.init();
            soundEngine.gameOver();
        }
        
        // Handle keyboard shortcuts in game over screen
        document.addEventListener('keydown', (e) => {
            if (game.state === 'over') {
                if (e.key === ' ' || e.key === 'Enter') {
                    e.preventDefault();
                    resetGame();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    window.location.href = '../games.html';
                }
            }
        });

        function schedulePowerupDrop(type, x, delay) {
            const t = normalizePowerType(type);
            if (!t) return;
            game.scheduledDrops.push({ type: t, x: clamp(x, 26, WORLD.w - 26), timer: Math.max(0, delay || 0) });
        }

        function spawnWave(waveNum) {
            game.wave = waveNum;
            const blueprint = wavePlans.get(waveNum) || localWavePlan(waveNum);
            if (wavePlans.has(waveNum)) wavePlans.delete(waveNum);
            requestWavePlan(waveNum + 1);

            (blueprint.enemies || []).forEach((enemy) => {
                const kind = (enemy.kind || enemy.type || 'drone');
                const pattern = (enemy.pattern || 'straight');
                const e = {
                    kind,
                    pattern,
                    x: clamp(Number(enemy.x ?? rand(44, WORLD.w - 44)), 28, WORLD.w - 28),
                    y: Number(enemy.y ?? -rand(30, 200)),
                    w: Number(enemy.w ?? 34),
                    h: Number(enemy.h ?? 24),
                    hp: Number(enemy.hp ?? 1),
                    speed: Number(enemy.speed ?? (settings.enemySpeed + rand(0, 55))) + waveNum * 4,
                    phase: Number(enemy.phase ?? rand(0, Math.PI * 2)),
                    t: 0,
                    baseX: 0,
                    fireTimer: rand(0.5, 1.6),
                };
                e.baseX = e.x;
                game.enemies.push(e);
            });

            (blueprint.powerups || []).forEach((drop) => {
                schedulePowerupDrop(drop.type, Number(drop.x ?? WORLD.w / 2), Number(drop.delay ?? 0.9));
            });

            game.nextWaveTimer = 0;
            updateHud();
        }

	        function spawnPlayerBullet(x, y, vx, vy) {
	            if (game.bullets.length >= 260) return;
	            game.bullets.push({ x, y, vx, vy, r: 3, life: 3.0 });
	        }

	        function spawnEnemyBullet(x, y, vx, vy, dmg) {
	            if (game.enemyBullets.length >= 360) return;
	            game.enemyBullets.push({ x, y, vx, vy, r: 3, dmg: dmg || settings.bulletDamage, life: 4.0 });
	        }

	        function explode(x, y, color) {
	            if (game.particles.length >= 900) return;
	            const c = color || 'rgba(110,231,255,0.9)';
	            for (let i = 0; i < 14; i++) {
	                if (game.particles.length >= 900) break;
	                const ang = rand(0, Math.PI * 2);
	                const sp = rand(60, 240);
	                game.particles.push({
	                    x,
	                    y,
                    vx: Math.cos(ang) * sp,
                    vy: Math.sin(ang) * sp,
                    life: rand(0.35, 0.75),
                    size: rand(1.2, 3.0),
                    color: c,
                });
            }
        }

        function applyPowerup(type) {
            const t = normalizePowerType(type);
            if (!t) return;
            if (t === 'shield') {
                game.player.lives = Math.min(settings.lives + 2, game.player.lives + 1);
                game.player.hp = game.player.maxHp;
                game.player.invuln = Math.max(game.player.invuln, 0.5);
            } else if (t === 'rapid') {
                game.player.rapidTimer = Math.max(game.player.rapidTimer, 7.0);
            } else if (t === 'multi') {
                game.player.multiTimer = Math.max(game.player.multiTimer, 10.0);
            }
            updateHud();
        }

        function fireIfReady(dt) {
            const p = game.player;
            p.fireTimer = Math.max(0, p.fireTimer - dt);

            const shouldFire = input.fireHeld || p.autofire;
            if (!shouldFire) return;
            if (p.fireTimer > 0) return;

            const rapidFactor = p.rapidTimer > 0 ? 0.52 : 1.0;
            const cd = clamp(p.baseFireCd * rapidFactor, 0.08, 0.5);
            p.fireTimer = cd;
            soundEngine.init();
            soundEngine.shoot();

            const speed = 660;
            if (p.multiTimer > 0) {
                const angles = [-0.25, 0, 0.25];
                for (const a of angles) {
                    const vx = Math.sin(a) * speed;
                    const vy = -Math.cos(a) * speed;
                    spawnPlayerBullet(p.x, p.y - 18, vx, vy);
                }
            } else {
                spawnPlayerBullet(p.x, p.y - 18, 0, -speed);
            }
        }

	        function updateHud() {
	            const hud = updateHud._cache || (updateHud._cache = Object.create(null));
	            function setHudText(el, key, value) {
	                if (hud[key] === value) return;
	                hud[key] = value;
	                el.textContent = value;
	            }

	            setHudText(scoreEl, 'score', String(game.score));
	            setHudText(waveEl, 'wave', String(game.wave || 1));
	            setHudText(hullEl, 'hull', `${Math.max(0, Math.round(game.player.hp))}%`);
	            setHudText(shieldsEl, 'shields', String(Math.max(0, game.player.lives)));

	            let weapon = 'Normal';
	            if (game.player.rapidTimer > 0) weapon = 'Rapid';
	            if (game.player.multiTimer > 0) weapon = weapon === 'Normal' ? 'Multi' : `${weapon} + Multi`;
	            setHudText(weaponEl, 'weapon', weapon);

	            setHudText(autofireEl, 'autofire', game.player.autofire ? 'On' : 'Off');
	        }

        function step(dt) {
            // Background stars always animate
            for (const s of game.stars) {
                s.y += s.speed * dt;
                if (s.y > WORLD.h) { s.y = 0; s.x = Math.random() * WORLD.w; }
            }

            for (let i = game.particles.length - 1; i >= 0; i--) {
                const p = game.particles[i];
                p.life -= dt;
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.vx *= 0.98;
                p.vy *= 0.98;
                if (p.life <= 0) game.particles.splice(i, 1);
            }

            if (game.state !== 'running') return;

            const player = game.player;
            player.invuln = Math.max(0, player.invuln - dt);
            player.rapidTimer = Math.max(0, player.rapidTimer - dt);
            player.multiTimer = Math.max(0, player.multiTimer - dt);

            const kbDir = (keys['arrowright'] || keys['d'] ? 1 : 0) - (keys['arrowleft'] || keys['a'] ? 1 : 0);
            if (input.pointerActive) {
                const targetX = clamp(input.pointerX, 24, WORLD.w - 24);
                const dx = targetX - player.x;
                const maxStep = player.speed * dt;
                player.x += clamp(dx, -maxStep, maxStep);
            } else {
                player.x += kbDir * player.speed * dt;
            }
            player.x = clamp(player.x, 24, WORLD.w - 24);

            fireIfReady(dt);

            for (let i = game.bullets.length - 1; i >= 0; i--) {
                const b = game.bullets[i];
                b.life -= dt;
                b.x += b.vx * dt;
                b.y += b.vy * dt;
                if (b.life <= 0 || b.y < -40 || b.x < -40 || b.x > WORLD.w + 40) {
                    game.bullets.splice(i, 1);
                }
            }

            for (let i = game.enemyBullets.length - 1; i >= 0; i--) {
                const b = game.enemyBullets[i];
                b.life -= dt;
                b.x += b.vx * dt;
                b.y += b.vy * dt;
                if (b.life <= 0 || b.y > WORLD.h + 60 || b.x < -60 || b.x > WORLD.w + 60) {
                    game.enemyBullets.splice(i, 1);
                }
            }

            for (let i = game.scheduledDrops.length - 1; i >= 0; i--) {
                const d = game.scheduledDrops[i];
                d.timer -= dt;
                if (d.timer <= 0) {
                    game.powerups.push({ x: d.x, y: -28, vy: 92, r: 12, type: d.type });
                    game.scheduledDrops.splice(i, 1);
                }
            }

            for (let i = game.powerups.length - 1; i >= 0; i--) {
                const p = game.powerups[i];
                p.y += p.vy * dt;
                if (p.y > WORLD.h + 50) game.powerups.splice(i, 1);
            }

            for (let i = game.enemies.length - 1; i >= 0; i--) {
                const e = game.enemies[i];
                e.t += dt;

                // Movement pattern (stable amplitude)
                let x = e.baseX;
                if (e.pattern === 'zigzag') x = e.baseX + Math.sin(e.t * 3.2 + e.phase) * 78;
                else if (e.pattern === 'strafe') x = e.baseX + Math.cos(e.t * 2.2 + e.phase) * 120;
                else if (e.pattern === 'sway') x = e.baseX + Math.sin(e.t * 1.5 + e.phase) * 56;
                e.x = clamp(x, 24, WORLD.w - 24);

                e.y += e.speed * dt;

                // Enemy firing (cooldown-based, always present)
                e.fireTimer -= dt;
                if (e.fireTimer <= 0 && e.y > -18 && e.y < WORLD.h - 40) {
                    const baseInterval = Math.max(0.45, settings.enemyFireBase - game.wave * 0.03);
                    e.fireTimer = baseInterval * (0.75 + Math.random() * 0.6);

                    const bulletSpeed = settings.enemyBulletSpeed + game.wave * 7;
                    if (e.kind === 'bomber') {
                        const angles = [-0.22, 0, 0.22];
                        for (const a of angles) {
                            const vx = Math.sin(a) * (bulletSpeed * 0.78);
                            const vy = Math.cos(a) * (bulletSpeed * 0.78);
                            spawnEnemyBullet(e.x, e.y + e.h / 2, vx, vy, settings.bulletDamage + 2);
                        }
                    } else if (e.kind === 'zig') {
                        const dx = player.x - e.x;
                        const dy = player.y - e.y;
                        const len = Math.max(1, Math.hypot(dx, dy));
                        spawnEnemyBullet(e.x, e.y + e.h / 2, (dx / len) * (bulletSpeed * 0.82), (dy / len) * (bulletSpeed * 0.82), settings.bulletDamage);
                    } else if (e.kind === 'slicer') {
                        spawnEnemyBullet(e.x, e.y + e.h / 2, 0, bulletSpeed * 1.12, settings.bulletDamage);
                    } else {
                        // drone
                        spawnEnemyBullet(e.x, e.y + e.h / 2, rand(-18, 18), bulletSpeed, settings.bulletDamage);
                    }
                }

                if (e.y > WORLD.h + 70 || e.hp <= 0) {
                    game.enemies.splice(i, 1);
                }
            }

	            // Collisions: player bullets -> enemies
	            for (let i = game.bullets.length - 1; i >= 0; i--) {
	                const b = game.bullets[i];
	                for (let j = game.enemies.length - 1; j >= 0; j--) {
	                    const e = game.enemies[j];
	                    if (e.hp <= 0) continue;
	                    if (Math.abs(b.x - e.x) < e.w / 2 && Math.abs(b.y - e.y) < e.h / 2) {
	                        e.hp -= 1;
	                        explode(b.x, b.y, 'rgba(110,231,255,0.85)');
	                        if (e.hp <= 0) {
	                            totalKills += 1;
	                            game.score += 12 + Math.round(game.wave * 1.5);
	                            explode(e.x, e.y, 'rgba(251, 113, 133, 0.85)');
	                            soundEngine.init();
	                            soundEngine.explode();
	                            if (Math.random() < 0.18) schedulePowerupDrop(Math.random() < 0.5 ? 'rapid' : 'multi', e.x, 0.25);
	                            game.enemies.splice(j, 1);
	                        } else {
	                            game.score += 3;
	                        }
	                        game.bullets.splice(i, 1);
	                        break;
	                    }
	                }
	            }

            // Enemy bullets -> player
            const px1 = player.x - player.w / 2;
            const px2 = player.x + player.w / 2;
            const py1 = player.y - player.h / 2;
            const py2 = player.y + player.h / 2;

            for (let i = game.enemyBullets.length - 1; i >= 0; i--) {
                const b = game.enemyBullets[i];
                const inBox = b.x > px1 && b.x < px2 && b.y > py1 && b.y < py2;
                if (!inBox) continue;
                game.enemyBullets.splice(i, 1);

                if (player.invuln > 0) continue;
                player.hp -= b.dmg;
                player.invuln = 0.18;
                explode(b.x, b.y, 'rgba(250, 204, 21, 0.85)');

	                if (player.hp <= 0) {
	                    player.lives -= 1;
	                    totalShieldsUsed += 1;
	                    player.hp = player.maxHp;
	                    player.invuln = 1.25;
	                    game.bullets = [];
	                    game.enemyBullets = [];
	                    game.powerups = [];
                    game.scheduledDrops = [];
                    explode(player.x, player.y, 'rgba(255, 122, 162, 0.9)');
                    if (player.lives <= 0) {
                        endGame('Shields depleted.');
                        break;
                    }
                }
            }

	            // Enemy body collision
	            for (const e of game.enemies) {
	                if (e.hp <= 0) continue;
	                const hit = Math.abs(e.x - player.x) < (e.w + player.w) / 2 && Math.abs(e.y - player.y) < (e.h + player.h) / 2;
	                if (!hit) continue;
	                if (player.invuln > 0) continue;
                
                // Direct collision = instant heavy damage
	                player.hp = 0;
	                player.lives -= 1;
	                totalShieldsUsed += 1;
	                explode(player.x, player.y, 'rgba(255, 122, 162, 0.9)');
	                soundEngine.init();
	                soundEngine.explode();
                
                if (player.lives <= 0) {
                    endGame('Collided with enemy ship.');
                    return;
                }
                
                // Respawn with invulnerability
                player.hp = player.maxHp;
                player.invuln = 1.5;
                game.bullets = [];
                game.enemyBullets = [];
                game.powerups = [];
                game.scheduledDrops = [];
                break;
            }

            // Powerup pickup
	            for (let i = game.powerups.length - 1; i >= 0; i--) {
	                const p = game.powerups[i];
	                const d = Math.hypot(p.x - player.x, p.y - player.y);
	                if (d < 22) {
	                    game.powerups.splice(i, 1);
	                    totalPowerups += 1;
	                    applyPowerup(p.type);
	                    explode(p.x, p.y, p.type === 'rapid' ? 'rgba(251,113,133,0.85)' : p.type === 'multi' ? 'rgba(250,204,21,0.85)' : 'rgba(110,231,255,0.85)');
	                    soundEngine.init();
	                    soundEngine.powerup();
	                }
            }

            // Wave progression
            if (game.enemies.length === 0 && game.scheduledDrops.length === 0 && game.state === 'running') {
                if (game.nextWaveTimer <= 0) {
                    game.nextWaveTimer = 0.9;
                } else {
                    game.nextWaveTimer -= dt;
                    if (game.nextWaveTimer <= 0) {
                        spawnWave(game.wave + 1);
                    }
                }
            }

	        }

	        function render() {
	            ctx.clearRect(0, 0, WORLD.w, WORLD.h);
	            ctx.fillStyle = bgGradient;
	            ctx.fillRect(0, 0, WORLD.w, WORLD.h);

	            // Nebula haze
	            ctx.fillStyle = hazeGradient;
	            ctx.fillRect(0, 0, WORLD.w, WORLD.h);

            // Stars
            for (const s of game.stars) {
                ctx.fillStyle = `rgba(255,255,255,${s.alpha})`;
                ctx.fillRect(s.x, s.y, s.size, s.size);
            }

            // Particles
            for (const p of game.particles) {
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, p.size, p.size);
            }

            // Player
            const player = game.player;
            const blink = player.invuln > 0 && Math.floor(performance.now() / 90) % 2 === 0;
            if (!blink) {
                ctx.save();
                ctx.translate(player.x, player.y);
                ctx.fillStyle = '#9de8c7';
                ctx.beginPath();
                ctx.moveTo(0, -18);
                ctx.lineTo(-20, 18);
                ctx.lineTo(20, 18);
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = 'rgba(110,231,255,0.4)';
                ctx.beginPath();
                ctx.moveTo(0, 18);
                ctx.lineTo(-6, 30);
                ctx.lineTo(6, 30);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }

            // Enemies
            for (const e of game.enemies) {
                const fill = e.kind === 'zig' ? '#fb7185' : e.kind === 'bomber' ? '#60a5fa' : e.kind === 'slicer' ? '#a78bfa' : '#fbbf24';
                ctx.fillStyle = fill;
                drawRoundRect(e.x - e.w / 2, e.y - e.h / 2, e.w, e.h, 8);
                ctx.fill();
                if (e.hp > 1) {
                    ctx.strokeStyle = 'rgba(255,255,255,0.35)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }

            // Powerups ("buds")
            for (const p of game.powerups) {
                const t = normalizePowerType(p.type);
                const fill = t === 'rapid' ? '#fb7185' : t === 'multi' ? '#facc15' : '#6ee7ff';
                ctx.fillStyle = fill;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 11, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = 'rgba(255,255,255,0.35)';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.font = '10px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(t === 'rapid' ? 'R' : t === 'multi' ? 'M' : 'S', p.x, p.y + 1);
            }

            // Bullets
            ctx.fillStyle = '#6ee7ff';
            for (const b of game.bullets) ctx.fillRect(b.x - 2, b.y - 10, 4, 12);

            ctx.fillStyle = '#fbbf24';
            for (const b of game.enemyBullets) ctx.fillRect(b.x - 2, b.y - 8, 4, 10);

            // In-canvas status
            if (game.state === 'paused') {
                ctx.fillStyle = 'rgba(0,0,0,0.55)';
                ctx.fillRect(0, 0, WORLD.w, WORLD.h);
                ctx.fillStyle = '#f1f3ff';
                ctx.font = 'bold 28px Poppins';
                ctx.textAlign = 'center';
                ctx.fillText('Paused', WORLD.w / 2, WORLD.h / 2 - 6);
                ctx.font = '14px Poppins';
                ctx.fillStyle = 'rgba(225, 230, 255, 0.85)';
                ctx.fillText('Press P to resume', WORLD.w / 2, WORLD.h / 2 + 22);
            }
        }

	        function frame(now) {
	            if (!game.lastTime) game.lastTime = now;
	            const rawDt = (now - game.lastTime) / 1000;
	            game.lastTime = now;
	            const frameDt = clamp(rawDt, 0, MAX_FRAME_DT);
	            game.accumulator += frameDt;

	            let steps = 0;
	            while (game.accumulator >= STEP && steps < MAX_STEPS_PER_FRAME) {
	                if (game.state !== 'over') step(STEP);
	                game.accumulator -= STEP;
	                steps += 1;
	            }
	            if (steps === MAX_STEPS_PER_FRAME) game.accumulator = 0;

	            updateHud();
	            render();
	            requestAnimationFrame(frame);
	        }

        pauseBtn.addEventListener('click', togglePause);
        restartBtn.addEventListener('click', resetGame);
        playAgainBtn.addEventListener('click', resetGame);
        startBtn.addEventListener('click', startGame);
        focusBtn.addEventListener('click', () => canvas.focus({ preventScroll: true }));

        resetGame();
        requestAnimationFrame(frame);
        
        // Initialize sound button
        const soundBtn = document.getElementById('soundBtn');
        soundBtn.textContent = soundEngine.isEnabled() ? 'üîä' : 'üîá';
        soundBtn.addEventListener('click', () => {
            soundEngine.init();
            soundEngine.toggle();
            soundBtn.textContent = soundEngine.isEnabled() ? 'üîä' : 'üîá';
            soundEngine.click();
        });
    </script>
</body>
</html>
