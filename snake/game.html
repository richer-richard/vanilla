<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake ‚Äî Play | VANILLA</title>
    <link rel="icon" type="image/svg+xml" href="../favicon.svg">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700;800&family=Press+Start+2P&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../styles.css">
    <style>
        body {
            min-height: 100vh;
        }

        header {
            padding: 16px 28px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: linear-gradient(90deg, rgba(102, 126, 234, 0.12), rgba(118, 75, 162, 0.1));
            border-bottom: 1px solid rgba(102, 126, 234, 0.3);
            position: sticky;
            top: 0;
            z-index: 5;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .crumb {
            color: #cdd2f1;
            letter-spacing: 0.6px;
            font-size: 12px;
        }

        .pill {
            padding: 10px 14px;
            border-radius: 12px;
            border: 1px solid rgba(102, 126, 234, 0.4);
            background: rgba(102, 126, 234, 0.12);
            color: #dfe4ff;
            font-weight: 700;
            font-size: 12px;
            letter-spacing: 0.4px;
        }

        .pill-link {
            text-decoration: none;
            color: #dfe4ff;
            border: 1px solid rgba(102, 126, 234, 0.4);
            padding: 10px 12px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.04);
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            letter-spacing: 0.8px;
            transition: all 0.2s ease;
        }

        .pill-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 24px rgba(0, 0, 0, 0.35);
            border-color: rgba(118, 75, 162, 0.75);
        }

        .header-actions {
            display: flex;
            gap: 10px;
        }

        .action-btn {
            padding: 10px 14px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.24), rgba(118, 75, 162, 0.2));
            color: #f2f4ff;
            font-weight: 700;
            letter-spacing: 0.3px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .action-btn.ghost {
            background: rgba(255, 255, 255, 0.06);
            border-color: rgba(255, 255, 255, 0.1);
        }

        .action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
        }

        main {
            width: min(1200px, 100%);
            margin: 0 auto;
            padding: 26px 24px 60px;
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 18px;
            align-items: start;
        }

        @media (max-width: 980px) {
            main {
                grid-template-columns: 1fr;
            }
        }

        .glass-card {
            background: linear-gradient(150deg, rgba(255, 255, 255, 0.02), rgba(102, 126, 234, 0.08));
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            box-shadow: 0 25px 70px rgba(0, 0, 0, 0.35), 0 10px 22px rgba(102, 126, 234, 0.1);
            padding: 18px;
            position: relative;
            overflow: hidden;
        }

        .glass-card::after {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 12% 18%, rgba(118, 75, 162, 0.14), transparent 32%),
                        radial-gradient(circle at 82% 8%, rgba(102, 126, 234, 0.12), transparent 30%);
            pointer-events: none;
        }

        .glass-card > * {
            position: relative;
            z-index: 1;
        }

        .hud {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-bottom: 12px;
        }

        .stat {
            padding: 12px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            background: rgba(255, 255, 255, 0.03);
        }

        .stat .label {
            font-size: 11px;
            color: #adb6da;
            letter-spacing: 0.6px;
            text-transform: uppercase;
        }

        .stat .value {
            font-size: 22px;
            font-weight: 800;
            margin-top: 4px;
        }

        .board-shell {
            margin-top: 8px;
            background: radial-gradient(circle at 20% 20%, rgba(102, 126, 234, 0.16), transparent 35%),
                        radial-gradient(circle at 80% 10%, rgba(118, 75, 162, 0.16), transparent 30%),
                        rgba(6, 9, 25, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            padding: 14px;
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.03);
        }

        canvas {
            width: 100%;
            height: auto;
            aspect-ratio: 1 / 1;
            display: block;
            border-radius: 12px;
            background: #050913;
        }

        .help-text {
            margin-top: 10px;
            color: #aeb7db;
            font-size: 13px;
            letter-spacing: 0.2px;
        }

        .sidebar h2 {
            margin: 6px 0 12px;
            font-size: 20px;
        }

        .tips {
            list-style: none;
            padding-left: 0;
            display: flex;
            flex-direction: column;
            gap: 10px;
            color: #cbd0ea;
        }

        .tips li {
            padding: 10px 12px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            background: rgba(255, 255, 255, 0.03);
        }

        .chip-row {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 14px;
        }

        .chip {
            padding: 8px 12px;
            border-radius: 10px;
            border: 1px solid rgba(102, 126, 234, 0.35);
            background: rgba(102, 126, 234, 0.08);
            color: #dfe4ff;
            font-weight: 600;
            font-size: 12px;
        }

        .eyebrow {
            letter-spacing: 1px;
            text-transform: uppercase;
            color: #9fb0ff;
            font-size: 11px;
        }
    </style>
</head>
<body class="game-page">
    <header>
        <div class="header-left">
            <a class="pill-link" href="../games.html">‚Üê Games</a>
            <span class="crumb">Snake</span>
            <span class="pill" id="difficultyLabel">Medium Grid</span>
        </div>
        <div class="header-actions">
            <button class="action-btn ghost" id="soundBtn" title="Toggle Sound">üîä</button>
            <button class="action-btn ghost" id="pauseBtn">Pause</button>
            <button class="action-btn" id="restartBtn">Restart</button>
        </div>
    </header>

    <main>
        <section class="glass-card">
            <div class="hud">
                <div class="stat">
                    <div class="label">Score</div>
                    <div class="value" id="score">0</div>
                </div>
                <div class="stat">
                    <div class="label">Best</div>
                    <div class="value" id="best">0</div>
                </div>
                <div class="stat">
                    <div class="label">Length</div>
                    <div class="value" id="length">0</div>
                </div>
                <div class="stat">
                    <div class="label">Pace</div>
                    <div class="value" id="pace">--</div>
                </div>
            </div>
            <div class="board-shell" style="position: relative;">
                <canvas id="board"></canvas>
                <div class="canvas-overlay active" id="startOverlay" style="position: absolute; inset: 14px; border-radius: 12px; display: grid; place-items: center; background: radial-gradient(circle at 20% 15%, rgba(78, 205, 196, 0.14), transparent 45%), radial-gradient(circle at 78% 22%, rgba(157, 232, 199, 0.14), transparent 50%), rgba(4, 7, 16, 0.82); border: 1px solid rgba(255, 255, 255, 0.08); backdrop-filter: blur(10px); padding: 16px; z-index: 10;">
                    <div style="width: min(420px, 100%); border-radius: 16px; border: 1px solid rgba(255, 255, 255, 0.10); background: rgba(255, 255, 255, 0.05); box-shadow: 0 26px 70px rgba(0, 0, 0, 0.45); padding: 24px; text-align: center;">
                        <div style="letter-spacing: 1px; text-transform: uppercase; color: #9de8c7; font-size: 11px; margin-bottom: 10px;">Ready to play</div>
                        <h2 style="font-size: 22px; line-height: 1.2; margin-bottom: 10px; color: #f2f3ff;">Thread the neon maze</h2>
                        <p style="margin: 0 auto 18px; color: rgba(238, 241, 255, 0.78); line-height: 1.6; font-size: 13px;">Use Arrow keys or WASD to move. Eat food to grow, but don't hit the walls or yourself!</p>
                        <button class="action-btn" id="startBtn" style="padding: 14px 28px; font-family: 'Press Start 2P', monospace; font-size: 11px;">Start Game</button>
                        <div style="margin-top: 14px; display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; font-size: 12px;">
                            <span style="font-family: 'Press Start 2P', monospace; font-size: 10px; padding: 8px 10px; border-radius: 10px; border: 1px solid rgba(255, 255, 255, 0.16); background: rgba(0, 0, 0, 0.24); color: #e9edff;">Space</span>
                            <span style="font-family: 'Press Start 2P', monospace; font-size: 10px; padding: 8px 10px; border-radius: 10px; border: 1px solid rgba(255, 255, 255, 0.16); background: rgba(0, 0, 0, 0.24); color: #e9edff;">WASD</span>
                            <span style="font-family: 'Press Start 2P', monospace; font-size: 10px; padding: 8px 10px; border-radius: 10px; border: 1px solid rgba(255, 255, 255, 0.16); background: rgba(0, 0, 0, 0.24); color: #e9edff;">R</span>
                        </div>
                    </div>
                </div>
            </div>
            <div class="help-text">Use Arrow keys or WASD to move. Space to pause, R to restart.</div>
        </section>

        <aside class="glass-card sidebar">
            <div class="eyebrow">Plan your run</div>
            <h2>Stay smooth, stay alive</h2>
            <ul class="tips">
                <li>Claim the perimeter early to avoid boxing yourself in later.</li>
                <li>Never reverse direction on instinct‚Äîsteer two moves ahead.</li>
                <li>Use pauses sparingly; the pace subtly ramps after each snack.</li>
            </ul>
            <div class="chip-row">
                <span class="chip">No wrap-around walls</span>
                <span class="chip">Local best saved per difficulty</span>
                <span class="chip">Instant restart</span>
            </div>
        </aside>
    </main>

    <div class="game-over-overlay" id="gameOverOverlay">
        <div class="game-over-content">
            <h1 id="gameOverTitle">Game Over</h1>
            <p id="finalScore">Score: 0</p>
            <p id="finalReason"></p>
            <div class="game-over-buttons">
                <button class="game-over-btn" id="playAgain">Play Again</button>
                <button class="game-over-btn" onclick="window.location.href='../games.html'">Back to Menu</button>
            </div>
        </div>
    </div>

    <script src="../sounds.js"></script>
    <script>
        const canvas = document.getElementById('board');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const bestEl = document.getElementById('best');
        const lengthEl = document.getElementById('length');
        const paceEl = document.getElementById('pace');
        const difficultyLabel = document.getElementById('difficultyLabel');
        const overlay = document.getElementById('gameOverOverlay');
        const finalScoreEl = document.getElementById('finalScore');
        const finalReasonEl = document.getElementById('finalReason');
        const playAgainBtn = document.getElementById('playAgain');
        const pauseBtn = document.getElementById('pauseBtn');
        const restartBtn = document.getElementById('restartBtn');
        const soundBtn = document.getElementById('soundBtn');

        // Initialize sound button
        soundBtn.textContent = soundEngine.isEnabled() ? 'üîä' : 'üîá';
        soundBtn.addEventListener('click', () => {
            soundEngine.init();
            soundEngine.toggle();
            soundBtn.textContent = soundEngine.isEnabled() ? 'üîä' : 'üîá';
            soundEngine.click();
        });

        const params = new URLSearchParams(window.location.search);
        const requestedDifficulty = (params.get('difficulty') || 'medium').toLowerCase();

        const DIFFICULTIES = {
            easy: { grid: 16, tick: 150, label: 'Easy' },
            medium: { grid: 18, tick: 115, label: 'Medium' },
            hard: { grid: 22, tick: 90, label: 'Hard' }
        };

        const settings = DIFFICULTIES[requestedDifficulty] || DIFFICULTIES.medium;
        difficultyLabel.textContent = `${settings.label} ‚Ä¢ ${settings.grid} √ó ${settings.grid}`;

        const bestKey = `vanilla-snake-${settings.label.toLowerCase()}-best`;
        let bestScore = Number(localStorage.getItem(bestKey)) || 0;

        let snake = [];
        let food = null;
        const foodQueue = [];
        let direction = { x: 1, y: 0 };
        let queuedDirection = { x: 1, y: 0 };
        let score = 0;
        let tickInterval = settings.tick;
        let lastFrame = 0;
        let accumulator = 0;
        let state = 'idle'; // idle | running | paused | over
        let animationId = null;
        let cellSize = 20;

        function resizeCanvas() {
            const container = canvas.parentElement;
            const containerWidth = container.clientWidth || 640;
            const maxHeight = Math.max(320, window.innerHeight - 220);
            const rawSize = Math.min(Math.min(containerWidth, maxHeight), 740);
            const snapped = rawSize - (rawSize % settings.grid);
            canvas.width = snapped;
            canvas.height = snapped;
            cellSize = snapped / settings.grid;
        }

        async function requestBackendFood() {
            try {
                const resp = await fetch('/api/snake/food', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ grid: settings.grid, snake })
                });
                if (!resp.ok) return;
                const data = await resp.json();
                if (typeof data.x === 'number' && typeof data.y === 'number') {
                    foodQueue.push({ x: data.x, y: data.y });
                }
            } catch (err) {
                console.warn('Snake backend food unavailable, using client RNG.', err);
            }
        }

        function placeFood() {
            const isOccupied = (candidate) => snake.some(segment => segment.x === candidate.x && segment.y === candidate.y);
            if (foodQueue.length > 0) {
                const candidate = foodQueue.shift();
                if (!isOccupied(candidate)) {
                    food = candidate;
                }
            }
            if (!food || isOccupied(food)) {
                let candidate;
                do {
                    candidate = {
                        x: Math.floor(Math.random() * settings.grid),
                        y: Math.floor(Math.random() * settings.grid)
                    };
                } while (isOccupied(candidate));
                food = candidate;
            }
            if (foodQueue.length < 2) requestBackendFood();
        }

        function resetGame() {
            overlay.classList.remove('active');
            score = 0;
            tickInterval = settings.tick;
            direction = { x: 1, y: 0 };
            queuedDirection = { x: 1, y: 0 };
            const center = Math.floor(settings.grid / 2);
            snake = [
                { x: center - 1, y: center },
                { x: center - 2, y: center },
                { x: center - 3, y: center }
            ];
            placeFood();
            requestBackendFood();
            state = 'running';
            accumulator = 0;
            lastFrame = performance.now();
            updateHud();
        }

        function updateHud() {
            scoreEl.textContent = score;
            bestEl.textContent = bestScore;
            lengthEl.textContent = snake.length;
            paceEl.textContent = `${Math.round(1000 / tickInterval)} steps/s`;
        }

        function setDirection(newDirection) {
            const opposite = newDirection.x === -direction.x && newDirection.y === -direction.y;
            if (opposite) return;
            queuedDirection = newDirection;
        }

        function handleInput(event) {
            const key = event.key.toLowerCase();
            const directionMap = {
                arrowup: { x: 0, y: -1 },
                w: { x: 0, y: -1 },
                arrowdown: { x: 0, y: 1 },
                s: { x: 0, y: 1 },
                arrowleft: { x: -1, y: 0 },
                a: { x: -1, y: 0 },
                arrowright: { x: 1, y: 0 },
                d: { x: 1, y: 0 }
            };

            if (key === ' ') {
                event.preventDefault();
                togglePause();
                return;
            }

            if (key === 'r') {
                event.preventDefault();
                resetGame();
                return;
            }

            if (directionMap[key]) {
                event.preventDefault();
                setDirection(directionMap[key]);
            }
        }

        function togglePause() {
            if (state === 'over') return;
            state = state === 'paused' ? 'running' : 'paused';
            pauseBtn.textContent = state === 'paused' ? 'Resume' : 'Pause';
        }

        function endGame(reason) {
            state = 'over';
            overlay.classList.add('active');
            finalScoreEl.textContent = `Score: ${score}`;
            finalReasonEl.textContent = reason;
            soundEngine.init();
            soundEngine.gameOver();
            if (score > bestScore) {
                bestScore = score;
                localStorage.setItem(bestKey, bestScore);
            }
            updateHud();
        }

        function step() {
            direction = queuedDirection;
            const head = snake[0];
            const next = { x: head.x + direction.x, y: head.y + direction.y };

            const outOfBounds =
                next.x < 0 || next.x >= settings.grid || next.y < 0 || next.y >= settings.grid;
            if (outOfBounds) {
                endGame('You hit the wall.');
                return;
            }

            const hitSelf = snake.some(seg => seg.x === next.x && seg.y === next.y);
            if (hitSelf) {
                endGame('You ran into yourself.');
                return;
            }

            snake.unshift(next);

            const ateFood = food && next.x === food.x && next.y === food.y;
            if (ateFood) {
                score += 10;
                tickInterval = Math.max(settings.tick * 0.6, tickInterval - 2);
                placeFood();
                soundEngine.init();
                soundEngine.coin();
            } else {
                snake.pop();
            }
            updateHud();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const background = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            background.addColorStop(0, '#0c132b');
            background.addColorStop(1, '#0a0f22');
            ctx.fillStyle = background;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.04)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= settings.grid; i++) {
                const offset = i * cellSize;
                ctx.beginPath();
                ctx.moveTo(offset, 0);
                ctx.lineTo(offset, canvas.height);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, offset);
                ctx.lineTo(canvas.width, offset);
                ctx.stroke();
            }

            if (food) {
                const fx = (food.x + 0.5) * cellSize;
                const fy = (food.y + 0.5) * cellSize;
                const radius = cellSize * 0.4;
                const gradient = ctx.createRadialGradient(fx, fy, radius * 0.2, fx, fy, radius);
                gradient.addColorStop(0, '#ffe29f');
                gradient.addColorStop(1, '#ff6b6b');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(fx, fy, radius, 0, Math.PI * 2);
                ctx.fill();
            }

            snake.forEach((segment, index) => {
                const x = segment.x * cellSize;
                const y = segment.y * cellSize;
                const isHead = index === 0;
                ctx.fillStyle = isHead ? '#9de8c7' : '#4ecdc4';
                ctx.shadowColor = isHead ? 'rgba(157, 232, 199, 0.45)' : 'rgba(78, 205, 196, 0.35)';
                ctx.shadowBlur = isHead ? 16 : 10;
                ctx.beginPath();
                if (ctx.roundRect) {
                    ctx.roundRect(
                        x + 2,
                        y + 2,
                        cellSize - 4,
                        cellSize - 4,
                        Math.min(8, cellSize / 3)
                    );
                } else {
                    ctx.rect(x + 2, y + 2, cellSize - 4, cellSize - 4);
                }
                ctx.fill();
            });
            ctx.shadowBlur = 0;

            if (state === 'paused') {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.45)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#f1f3ff';
                ctx.font = `bold ${Math.max(20, cellSize)}px Poppins`;
                ctx.textAlign = 'center';
                ctx.fillText('Paused', canvas.width / 2, canvas.height / 2);
            }
        }

        function loop(timestamp) {
            animationId = requestAnimationFrame(loop);
            if (lastFrame === 0) {
                lastFrame = timestamp;
            }
            const delta = timestamp - lastFrame;
            lastFrame = timestamp;

            if (state === 'running') {
                accumulator += delta;
                while (accumulator >= tickInterval) {
                    step();
                    accumulator -= tickInterval;
                    if (state === 'over') break;
                }
            }
            draw();
        }

        function startLoop() {
            if (animationId === null) {
                animationId = requestAnimationFrame(loop);
            }
        }

        pauseBtn.addEventListener('click', togglePause);
        restartBtn.addEventListener('click', resetGame);
        playAgainBtn.addEventListener('click', resetGame);
        document.addEventListener('keydown', handleInput);
        window.addEventListener('resize', () => {
            resizeCanvas();
            draw();
        });

        // Start overlay handling
        const startOverlay = document.getElementById('startOverlay');
        const startBtn = document.getElementById('startBtn');
        
        function showStartOverlay() {
            startOverlay.style.display = 'grid';
            state = 'idle';
        }
        
        function hideStartOverlay() {
            startOverlay.style.display = 'none';
        }
        
        function startGame() {
            hideStartOverlay();
            soundEngine.init();
            resetGame();
        }
        
        startBtn.addEventListener('click', startGame);
        
        // Override resetGame to not auto-start
        const originalResetGame = resetGame;
        resetGame = function() {
            overlay.classList.remove('active');
            score = 0;
            tickInterval = settings.tick;
            direction = { x: 1, y: 0 };
            queuedDirection = { x: 1, y: 0 };
            const center = Math.floor(settings.grid / 2);
            snake = [
                { x: center - 1, y: center },
                { x: center - 2, y: center },
                { x: center - 3, y: center }
            ];
            placeFood();
            requestBackendFood();
            state = 'running';
            accumulator = 0;
            lastFrame = performance.now();
            updateHud();
        };

        resizeCanvas();
        // Don't auto-start - show overlay instead
        score = 0;
        tickInterval = settings.tick;
        const center = Math.floor(settings.grid / 2);
        snake = [
            { x: center - 1, y: center },
            { x: center - 2, y: center },
            { x: center - 3, y: center }
        ];
        placeFood();
        updateHud();
        state = 'idle';
        startLoop();
    </script>
</body>
</html>
