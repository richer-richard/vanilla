<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pong ‚Äî Play | VANILLA</title>
    <link rel="icon" type="image/svg+xml" href="../favicon.svg">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700;800&family=Press+Start+2P&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../styles.css">
    <style>
        body { min-height: 100vh; }
        header {
            padding: 16px 28px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: linear-gradient(90deg, rgba(102, 126, 234, 0.12), rgba(118, 75, 162, 0.1));
            border-bottom: 1px solid rgba(102, 126, 234, 0.3);
            position: sticky;
            top: 0;
            z-index: 5;
        }
        .header-left { display: flex; align-items: center; gap: 12px; }
        .crumb { color: #cdd2f1; letter-spacing: 0.6px; font-size: 12px; }
        .pill { padding: 10px 14px; border-radius: 12px; border: 1px solid rgba(102, 126, 234, 0.4); background: rgba(102, 126, 234, 0.12); color: #dfe4ff; font-weight: 700; font-size: 12px; letter-spacing: 0.4px; }
        .pill-link {
            text-decoration: none;
            color: #dfe4ff;
            border: 1px solid rgba(102, 126, 234, 0.4);
            padding: 10px 12px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.04);
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            letter-spacing: 0.8px;
            transition: all 0.2s ease;
        }
        .pill-link:hover { transform: translateY(-2px); box-shadow: 0 10px 24px rgba(0, 0, 0, 0.35); border-color: rgba(118, 75, 162, 0.75); }
        .header-actions { display: flex; gap: 10px; }
        .action-btn {
            padding: 10px 14px; border-radius: 12px; border: 1px solid rgba(255, 255, 255, 0.15);
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.24), rgba(118, 75, 162, 0.2));
            color: #f2f4ff; font-weight: 700; letter-spacing: 0.3px; cursor: pointer; transition: all 0.2s ease;
        }
        .action-btn.ghost { background: rgba(255, 255, 255, 0.06); border-color: rgba(255, 255, 255, 0.1); }
        .action-btn:hover { transform: translateY(-2px); box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35); }
        main {
            width: min(1100px, 100%);
            margin: 0 auto;
            padding: 26px 24px 60px;
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 18px;
            align-items: start;
        }
        @media (max-width: 960px) { main { grid-template-columns: 1fr; } }
        .glass-card {
            background: linear-gradient(150deg, rgba(255, 255, 255, 0.02), rgba(102, 126, 234, 0.08));
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            box-shadow: 0 25px 70px rgba(0, 0, 0, 0.35), 0 10px 22px rgba(102, 126, 234, 0.1);
            padding: 18px;
            position: relative;
            overflow: hidden;
        }
        .glass-card::after { content: ''; position: absolute; inset: 0; background: radial-gradient(circle at 12% 18%, rgba(118, 75, 162, 0.14), transparent 32%), radial-gradient(circle at 82% 8%, rgba(102, 126, 234, 0.12), transparent 30%); pointer-events: none; }
        .glass-card > * { position: relative; z-index: 1; }
        .hud { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; margin-bottom: 12px; }
        .stat { padding: 12px; border-radius: 12px; border: 1px solid rgba(255, 255, 255, 0.08); background: rgba(255, 255, 255, 0.03); }
        .stat .label { font-size: 11px; color: #adb6da; letter-spacing: 0.6px; text-transform: uppercase; }
        .stat .value { font-size: 22px; font-weight: 800; margin-top: 4px; }
        .board-shell { margin-top: 8px; background: radial-gradient(circle at 20% 20%, rgba(102, 126, 234, 0.16), transparent 35%), radial-gradient(circle at 80% 10%, rgba(118, 75, 162, 0.16), transparent 30%), rgba(6, 9, 25, 0.9); border: 1px solid rgba(255, 255, 255, 0.08); border-radius: 16px; padding: 14px; box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.03); }
        .board-shell { position: relative; overflow: hidden; --overlay-inset: 14px; --overlay-radius: 12px; }
        canvas { width: 100%; height: auto; aspect-ratio: 4 / 3; display: block; background: #050913; border-radius: 12px; }
        .sidebar h2 { margin: 6px 0 12px; font-size: 20px; }
        .tips { list-style: none; padding-left: 0; display: flex; flex-direction: column; gap: 10px; color: #cbd0ea; }
        .tips li { padding: 10px 12px; border-radius: 12px; border: 1px solid rgba(255, 255, 255, 0.08); background: rgba(255, 255, 255, 0.03); }
        .chip-row { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 14px; }
        .chip { padding: 8px 12px; border-radius: 10px; border: 1px solid rgba(102, 126, 234, 0.35); background: rgba(102, 126, 234, 0.08); color: #dfe4ff; font-weight: 600; font-size: 12px; }
        .eyebrow { letter-spacing: 1px; text-transform: uppercase; color: #9fb0ff; font-size: 11px; }
    </style>
</head>
<body class="game-page">
    <header>
        <div class="header-left">
            <a class="pill-link" href="../games.html">‚Üê Games</a>
            <span class="crumb">Pong</span>
            <span class="pill" id="difficultyLabel">Medium Rally</span>
        </div>
        <div class="header-actions">
            <button class="action-btn ghost" id="soundBtn" title="Toggle Sound">üîä</button>
            <button class="action-btn ghost" id="pauseBtn">Pause</button>
            <button class="action-btn" id="restartBtn">Restart</button>
        </div>
    </header>

    <main>
        <section class="glass-card">
            <div class="hud">
                <div class="stat"><div class="label">You</div><div class="value" id="playerScore">0</div></div>
                <div class="stat"><div class="label">AI</div><div class="value" id="aiScore">0</div></div>
                <div class="stat"><div class="label">Race To</div><div class="value" id="raceTo">9</div></div>
                <div class="stat"><div class="label">Pace</div><div class="value" id="pace">--</div></div>
            </div>
            <div class="board-shell">
                <canvas id="board"></canvas>
                <div class="canvas-overlay active" id="startOverlay">
                    <div class="overlay-card">
                        <div class="eyebrow">Ready to rally</div>
                        <h1>Win the race.</h1>
                        <p>Move your paddle, serve the ball, and outplay the AI. Use angled returns to force mistakes.</p>
                        <div class="overlay-actions">
                            <button class="primary-btn" id="startBtn" type="button">Start</button>
                        </div>
                        <div class="kbd-row">
                            <span class="kbd">W/S</span>
                            <span class="kbd">‚Üë/‚Üì</span>
                            <span class="kbd">Space</span>
                            <span class="kbd">P</span>
                            <span class="kbd">R</span>
                        </div>
                    </div>
                </div>
            </div>
            <div style="margin-top:10px;color:#aeb7db;font-size:13px;">Move with W/S or ‚Üë/‚Üì. Space to serve. P to pause.</div>
        </section>

        <aside class="glass-card sidebar">
            <div class="eyebrow">Control the center</div>
            <h2>Keep a calm rally</h2>
            <ul class="tips">
                <li>Return to mid-court after each hit to cut angles.</li>
                <li>Edge hits add spin‚Äîuse them sparingly.</li>
                <li>Serve with a slight offset to keep AI honest.</li>
            </ul>
            <div class="chip-row">
                <span class="chip">Adaptive AI tracking</span>
                <span class="chip">Momentum trail</span>
                <span class="chip">Instant restart</span>
            </div>
        </aside>
    </main>

    <div class="game-over-overlay" id="gameOverOverlay">
        <div class="game-over-content">
            <div class="game-over-header">
                <div class="game-over-icon" id="gameOverIcon">üèì</div>
                <div class="game-over-eyebrow" id="gameOverEyebrow">MATCH COMPLETE</div>
                <h1 id="gameOverTitle">Game Over</h1>
                <p class="game-over-subtitle" id="gameOverSubtitle">You gave it your best</p>
            </div>
            
            <div class="game-over-stats">
                <div class="game-over-stats-grid">
                    <div class="game-over-stat highlight" id="playerStatBox">
                        <div class="game-over-stat-value" id="finalPlayerValue">0</div>
                        <div class="game-over-stat-label">Your Score</div>
                    </div>
                    <div class="game-over-stat" id="aiStatBox">
                        <div class="game-over-stat-value" id="finalAiValue">0</div>
                        <div class="game-over-stat-label">AI Score</div>
                    </div>
                    <div class="game-over-stat">
                        <div class="game-over-stat-value" id="finalRallyValue">0</div>
                        <div class="game-over-stat-label">Longest Rally</div>
                    </div>
                    <div class="game-over-stat">
                        <div class="game-over-stat-value" id="finalPaceValue">--</div>
                        <div class="game-over-stat-label">Max Speed</div>
                    </div>
                    <div class="game-over-stat">
                        <div class="game-over-stat-value" id="finalRaceValue">9</div>
                        <div class="game-over-stat-label">Race To</div>
                    </div>
                    <div class="game-over-stat">
                        <div class="game-over-stat-value" id="finalDiffValue">--</div>
                        <div class="game-over-stat-label">Difficulty</div>
                    </div>
                </div>
            </div>
            
            <div class="game-over-message" id="gameOverMessage">
                <div class="game-over-message-icon">üí°</div>
                <div class="game-over-message-text">
                    <div class="game-over-message-title" id="messageTitleEl">Control the center</div>
                    <div class="game-over-message-desc" id="messageDescEl">Return to mid-court after each hit to cut angles.</div>
                </div>
            </div>
            
            <div class="game-over-hints">
                <div class="game-over-hint"><kbd>Space</kbd> Play again</div>
                <div class="game-over-hint"><kbd>Esc</kbd> Back to menu</div>
            </div>
            
            <div class="game-over-buttons">
                <button class="game-over-btn primary" id="playAgain">Play Again</button>
                <button class="game-over-btn secondary" onclick="window.location.href='../games.html'">Back to Menu</button>
            </div>
        </div>
    </div>

    <script src="../sounds.js"></script>
    <script>
        const canvas = document.getElementById('board');
        const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });
        const playerScoreEl = document.getElementById('playerScore');
        const aiScoreEl = document.getElementById('aiScore');
        const raceToEl = document.getElementById('raceTo');
        const paceEl = document.getElementById('pace');
        const difficultyLabel = document.getElementById('difficultyLabel');
        const overlay = document.getElementById('gameOverOverlay');
        const finalScoreEl = document.getElementById('finalScore');
        const playAgainBtn = document.getElementById('playAgain');
        const pauseBtn = document.getElementById('pauseBtn');
        const restartBtn = document.getElementById('restartBtn');
        const soundBtn = document.getElementById('soundBtn');

        const startOverlay = document.getElementById('startOverlay');
        const startBtn = document.getElementById('startBtn');
        let hasStarted = false;

        function startOrServe() {
            if (!hasStarted) {
                hasStarted = true;
                startOverlay.classList.remove('active');
                soundEngine.init();
            }
            if (state === 'ready') state = 'running';
        }

        const params = new URLSearchParams(window.location.search);
        const requestedDifficulty = (params.get('difficulty') || 'medium').toLowerCase();

        const CONFIG = {
            easy: { ball: 5.5, aiSpeed: 5.2, aiError: 70, target: 7, label: 'Easy', aiMissChance: 0.18, aiLag: 6 },
            medium: { ball: 7.0, aiSpeed: 6.5, aiError: 50, target: 9, label: 'Medium', aiMissChance: 0.12, aiLag: 4 },
            hard: { ball: 8.5, aiSpeed: 7.8, aiError: 35, target: 11, label: 'Hard', aiMissChance: 0.06, aiLag: 2 }
        };
        const settings = CONFIG[requestedDifficulty] || CONFIG.medium;
        difficultyLabel.textContent = `${settings.label} ‚Ä¢ Race to ${settings.target}`;
        raceToEl.textContent = settings.target;

        const BASE_FPS = 60;
        const TARGET_FPS = 120;
        const FRAME_SCALE = TARGET_FPS / BASE_FPS;
        const TICK_SCALE = BASE_FPS / TARGET_FPS;
        const STEP_MS = 1000 / TARGET_FPS;
        const MAX_FRAME_MS = 50;
        const MAX_STEPS_PER_FRAME = Math.ceil(MAX_FRAME_MS / STEP_MS);
        const TRAIL_LENGTH = Math.round(12 * FRAME_SCALE);

        function clamp(value, min, max) {
            return Math.max(min, Math.min(max, value));
        }

        function defaultPhysics(difficultyKey) {
            const diff = (difficultyKey || 'medium').toLowerCase();
            const base = {
                easy:   { maxBounceDeg: 52, paddleInfluence: 0.10, spinFromPaddle: 0.010, spinFromEdge: 0.08, spinCurvature: 0.040, spinDecay: 0.992, maxSpin: 0.65, speedUpHit: 0.25, maxSpeed: settings.ball + 4.0 },
                medium: { maxBounceDeg: 56, paddleInfluence: 0.12, spinFromPaddle: 0.012, spinFromEdge: 0.10, spinCurvature: 0.050, spinDecay: 0.991, maxSpin: 0.75, speedUpHit: 0.30, maxSpeed: settings.ball + 5.0 },
                hard:   { maxBounceDeg: 60, paddleInfluence: 0.14, spinFromPaddle: 0.014, spinFromEdge: 0.12, spinCurvature: 0.060, spinDecay: 0.990, maxSpin: 0.85, speedUpHit: 0.35, maxSpeed: settings.ball + 6.0 },
            }[diff] || { maxBounceDeg: 56, paddleInfluence: 0.12, spinFromPaddle: 0.012, spinFromEdge: 0.10, spinCurvature: 0.050, spinDecay: 0.991, maxSpin: 0.75, speedUpHit: 0.30, maxSpeed: settings.ball + 5.0 };
            return { ...base };
        }

        let physics = defaultPhysics(requestedDifficulty);

        function applyBackendPhysics(payload) {
            if (!payload || typeof payload !== 'object') return;
            const merged = { ...physics };
            for (const [key, value] of Object.entries(payload)) {
                if (typeof value === 'number' && Number.isFinite(value)) merged[key] = value;
            }
            physics = merged;
        }

        let width = 800;
        let height = 600;
        const paddle = { width: 14, height: 96, speed: 7, x: 0, y: 0, vy: 0 };
        const ai = { width: 14, height: 96, speed: settings.aiSpeed, x: 0, y: 0, vy: 0, targetY: 0, idleFrames: 0, missBounce: null };
        const ball = { x: 0, y: 0, r: 9, dx: settings.ball, dy: settings.ball * 0.55, speed: settings.ball, spin: 0, trail: [] };
        let state = 'ready'; // ready | running | paused | over
        let scores = { player: 0, ai: 0 };
        const keys = {};
        let bounceId = 0;
        let lastTime = 0;
        let accumulator = 0;
        const hudCache = { player: null, ai: null, pace: null };

        function resizeCanvas() {
            const container = canvas.parentElement;
            width = Math.min(940, container.clientWidth);
            height = Math.round(width * 0.65);
            canvas.width = width;
            canvas.height = height;
            resetPositions();
            draw();
        }

        function resetPositions() {
            paddle.x = 18;
            paddle.y = height / 2 - paddle.height / 2;
            paddle.vy = 0;
            ai.x = width - paddle.width - 18;
            ai.y = height / 2 - ai.height / 2;
            ai.vy = 0;
            ai.targetY = height / 2;
            ai.idleFrames = 0;
            ai.missBounce = null;
            ball.x = width / 2;
            ball.y = height / 2;
            ball.speed = settings.ball;
            ball.dx = ball.speed * (Math.random() > 0.5 ? 1 : -1);
            ball.dy = ball.speed * (Math.random() * 0.6 - 0.3);
            ball.spin = 0;
            ball.trail = [];
            noteBounce('serve');
        }

        function resetMatch() {
            overlay.classList.remove('active');
            scores = { player: 0, ai: 0 };
            state = 'ready';
            bounceId = 0;
            resetPositions();
            updateHud();
        }

        function updateHud() {
            if (hudCache.player !== scores.player) {
                hudCache.player = scores.player;
                playerScoreEl.textContent = scores.player;
            }
            if (hudCache.ai !== scores.ai) {
                hudCache.ai = scores.ai;
                aiScoreEl.textContent = scores.ai;
            }
            const paceText = `${Math.round(ball.speed * BASE_FPS)} px/s`;
            if (hudCache.pace !== paceText) {
                hudCache.pace = paceText;
                paceEl.textContent = paceText;
            }
        }

        document.addEventListener('keydown', e => {
            keys[e.key.toLowerCase()] = true;
            if (e.key === ' ') {
                e.preventDefault();
                startOrServe();
            } else if (e.key.toLowerCase() === 'p') {
                togglePause();
            } else if (e.key.toLowerCase() === 'r') {
                resetMatch();
            }
        });
        document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

        function togglePause() {
            if (state === 'over') return;
            state = state === 'paused' ? 'running' : 'paused';
            pauseBtn.textContent = state === 'paused' ? 'Resume' : 'Pause';
        }

        function clampTargetY(target) {
            const min = paddle.height / 2 + 12;
            const max = height - paddle.height / 2 - 12;
            return Math.max(min, Math.min(max, target));
        }

        function localAiPlan(reason) {
            const ballHeadingToAi = ball.dx > 0;
            let targetY;
            if (!ballHeadingToAi) {
                targetY = height / 2 + (Math.random() - 0.5) * (settings.aiError * 0.35);
            } else {
                const travel = (ai.x - ball.x) / Math.max(1, Math.abs(ball.dx));
                let predicted = ball.y + ball.dy * travel;
                // mirror against top/bottom to approximate wall bounces
                while (predicted < 0 || predicted > height) {
                    predicted = predicted < 0 ? -predicted : height - (predicted - height);
                }
                const wobble = (Math.random() - 0.5) * settings.aiError;
                targetY = predicted + wobble;
            }
            const miss = Math.random() < settings.aiMissChance;
            return { targetY: clampTargetY(targetY), miss };
        }

        function applyAiPlan(plan, tag) {
            if (tag !== bounceId) return;
            ai.targetY = clampTargetY(plan.targetY);
            ai.missBounce = plan.miss ? tag : null;
            const idleFrames = Number.isFinite(plan.idle) ? plan.idle : settings.aiLag;
            ai.idleFrames = Math.max(ai.idleFrames, Math.round(idleFrames * FRAME_SCALE));
        }

        async function requestBackendAiPlan(reason, tag) {
            try {
                const resp = await fetch('/api/pong/ai-target', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        difficulty: settings.label.toLowerCase(),
                        bounce: { id: tag, reason },
                        ball: { x: ball.x, y: ball.y, dx: ball.dx, dy: ball.dy },
                        ai: { y: ai.y, height: ai.height },
                        player: { y: paddle.y, height: paddle.height },
                        court: { width, height }
                    })
                });
                if (!resp.ok) return;
                const data = await resp.json();
                if (data.physics) applyBackendPhysics(data.physics);
                if (typeof data.targetY === 'number') {
                    applyAiPlan({ targetY: data.targetY, miss: !!data.miss, idle: data.idle }, tag);
                }
            } catch (err) {
                console.warn('AI backend unavailable, staying on local plan.', err);
            }
        }

        function noteBounce(reason) {
            bounceId += 1;
            const tag = bounceId;
            applyAiPlan(localAiPlan(reason), tag);
            requestBackendAiPlan(reason, tag);
        }

        function movePaddles() {
            const prevPlayerY = paddle.y;
            if (keys['arrowup'] || keys['w']) paddle.y -= paddle.speed * TICK_SCALE;
            if (keys['arrowdown'] || keys['s']) paddle.y += paddle.speed * TICK_SCALE;
            paddle.y = Math.max(10, Math.min(height - paddle.height - 10, paddle.y));
            paddle.vy = (paddle.y - prevPlayerY) / Math.max(TICK_SCALE, 1e-6);

            const prevAiY = ai.y;
            const aiCenter = ai.y + ai.height / 2;
            if (ai.idleFrames > 0) {
                ai.idleFrames -= 1;
            } else {
                const delta = ai.targetY - aiCenter;
                const missFactor = ai.missBounce === bounceId ? 0.45 : 1;
                const maxStep = settings.aiSpeed * missFactor;
                const step = Math.max(-maxStep, Math.min(maxStep, delta));
                ai.y += step * 0.9 * TICK_SCALE;
            }
            ai.y = Math.max(10, Math.min(height - ai.height - 10, ai.y));
            ai.vy = (ai.y - prevAiY) / Math.max(TICK_SCALE, 1e-6);
        }

        function stepBall() {
            if (physics.spinCurvature && Math.abs(ball.spin) > 1e-4) {
                ball.dy += ball.spin * physics.spinCurvature * TICK_SCALE;
                const mag = Math.max(0.001, Math.hypot(ball.dx, ball.dy));
                const scale = ball.speed / mag;
                ball.dx *= scale;
                ball.dy *= scale;
            }
            ball.spin *= physics.spinDecay;

            ball.x += ball.dx * TICK_SCALE;
            ball.y += ball.dy * TICK_SCALE;
            ball.trail.push({ x: ball.x, y: ball.y });
            if (ball.trail.length > TRAIL_LENGTH) ball.trail.shift();

            if (ball.y - ball.r < 0 || ball.y + ball.r > height) {
                ball.dy *= -1;
                ball.spin *= -0.85;
                ball.y = clamp(ball.y, ball.r, height - ball.r);
                noteBounce('wall');
                soundEngine.init();
                soundEngine.beep(200, 0.05, 0.2);
            }

            const hitPaddle = (p, who, dir) => {
                const approaching = dir > 0 ? ball.dx < 0 : ball.dx > 0;
                if (!approaching) return;
                if (
                    ball.x - ball.r < p.x + p.width &&
                    ball.x + ball.r > p.x &&
                    ball.y + ball.r > p.y &&
                    ball.y - ball.r < p.y + p.height
                ) {
                    const offset = (ball.y - (p.y + p.height / 2)) / (p.height / 2);
                    const clampedOffset = clamp(offset, -1, 1);
                    const maxAngle = (physics.maxBounceDeg * Math.PI) / 180;
                    const angle = clampedOffset * maxAngle;

                    ball.speed = Math.min(ball.speed + physics.speedUpHit, physics.maxSpeed);

                    let vx = dir * ball.speed * Math.cos(angle);
                    let vy = ball.speed * Math.sin(angle);
                    const pv = p.vy || 0;
                    vy += pv * physics.paddleInfluence;

                    const mag = Math.max(0.001, Math.hypot(vx, vy));
                    const scale = ball.speed / mag;
                    ball.dx = vx * scale;
                    ball.dy = vy * scale;
                    ball.spin = clamp(
                        ball.spin + pv * physics.spinFromPaddle + clampedOffset * physics.spinFromEdge,
                        -physics.maxSpin,
                        physics.maxSpin
                    );

                    ball.x = dir > 0 ? p.x + p.width + ball.r : p.x - ball.r;
                    noteBounce(`${who}-paddle`);
                    soundEngine.init();
                    soundEngine.hit();
                }
            };

            hitPaddle(paddle, 'player', 1);
            hitPaddle(ai, 'ai', -1);

            if (ball.x < 0) {
                scores.ai += 1;
                soundEngine.init();
                soundEngine.beep(150, 0.2, 0.3);
                handlePoint();
            } else if (ball.x > width) {
                scores.player += 1;
                soundEngine.init();
                soundEngine.victory();
                handlePoint();
            }
        }

        function handlePoint() {
            if (scores.player >= settings.target || scores.ai >= settings.target) {
                endGame();
                return;
            }
            state = 'ready';
            resetPositions();
            updateHud();
        }

        // Game over screen elements
        const gameOverIcon = document.getElementById('gameOverIcon');
        const gameOverEyebrow = document.getElementById('gameOverEyebrow');
        const gameOverTitle = document.getElementById('gameOverTitle');
        const gameOverSubtitle = document.getElementById('gameOverSubtitle');
        const finalPlayerValue = document.getElementById('finalPlayerValue');
        const finalAiValue = document.getElementById('finalAiValue');
        const finalRallyValue = document.getElementById('finalRallyValue');
        const finalPaceValue = document.getElementById('finalPaceValue');
        const finalRaceValue = document.getElementById('finalRaceValue');
        const finalDiffValue = document.getElementById('finalDiffValue');
        const playerStatBox = document.getElementById('playerStatBox');
        const messageTitleEl = document.getElementById('messageTitleEl');
        const messageDescEl = document.getElementById('messageDescEl');

        let longestRally = 0;
        let currentRally = 0;
        let maxSpeed = settings.ball;

        const tips = [
            { title: "Center Control", desc: "Return to mid-court after each hit to cut off angles." },
            { title: "Edge Spin", desc: "Hit near the paddle edge to add spin‚Äîuse sparingly." },
            { title: "Serve Strategy", desc: "Serve with slight offset to keep AI guessing." },
            { title: "Watch the Bounce", desc: "Predict wall bounces to position yourself early." },
            { title: "Patience Wins", desc: "Don't reach too far‚Äîlet the AI make mistakes." },
            { title: "Speed Awareness", desc: "Ball speeds up each rally. Stay calm under pressure." }
        ];

        function getRandomTip() {
            return tips[Math.floor(Math.random() * tips.length)];
        }

        function endGame() {
            state = 'over';
            const playerWon = scores.player >= settings.target;
            
            // Update max speed
            maxSpeed = Math.max(maxSpeed, ball.speed);
            
            // Configure overlay based on outcome
            if (playerWon) {
                overlay.classList.add('victory');
                gameOverIcon.textContent = 'üèÜ';
                gameOverIcon.classList.add('victory');
                gameOverEyebrow.textContent = 'VICTORY!';
                gameOverEyebrow.classList.add('victory');
                gameOverTitle.textContent = 'You Win!';
                gameOverSubtitle.textContent = `Dominated the AI ${scores.player}-${scores.ai}`;
                playerStatBox.classList.add('new-record');
                playerStatBox.classList.remove('highlight');
            } else {
                overlay.classList.remove('victory');
                gameOverIcon.textContent = 'üèì';
                gameOverIcon.classList.remove('victory');
                gameOverEyebrow.textContent = 'MATCH COMPLETE';
                gameOverEyebrow.classList.remove('victory');
                gameOverTitle.textContent = 'Game Over';
                gameOverSubtitle.textContent = `AI won ${scores.ai}-${scores.player}`;
                playerStatBox.classList.remove('new-record');
                playerStatBox.classList.add('highlight');
            }
            
            // Populate stats
            finalPlayerValue.textContent = scores.player;
            finalAiValue.textContent = scores.ai;
            finalRallyValue.textContent = longestRally;
            finalPaceValue.textContent = `${Math.round(maxSpeed * BASE_FPS)}`;
            finalRaceValue.textContent = settings.target;
            finalDiffValue.textContent = settings.label;
            
            // Set tip message
            const tip = getRandomTip();
            messageTitleEl.textContent = tip.title;
            messageDescEl.textContent = tip.desc;
            
            // Show overlay
            overlay.classList.add('active');
            
            soundEngine.init();
            if (playerWon) {
                soundEngine.victory();
            } else {
                soundEngine.gameOver();
            }
        }
        
        // Handle keyboard shortcuts in game over screen
        document.addEventListener('keydown', (e) => {
            if (state === 'over') {
                if (e.key === ' ' || e.key === 'Enter') {
                    e.preventDefault();
                    resetMatch();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    window.location.href = '../games.html';
                }
            }
        });

        function draw() {
            ctx.clearRect(0, 0, width, height);
            const bg = ctx.createLinearGradient(0, 0, 0, height);
            bg.addColorStop(0, '#0c132b');
            bg.addColorStop(1, '#0a0f22');
            ctx.fillStyle = bg;
            ctx.fillRect(0, 0, width, height);

            ctx.setLineDash([8, 10]);
            ctx.strokeStyle = 'rgba(255,255,255,0.18)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width / 2, 0);
            ctx.lineTo(width / 2, height);
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.fillStyle = '#9de8c7';
            ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
            ctx.fillStyle = '#fca5a5';
            ctx.fillRect(ai.x, ai.y, ai.width, ai.height);

            for (let i = 0; i < ball.trail.length; i++) {
                const t = ball.trail[i];
                const alpha = i / ball.trail.length;
                ctx.fillStyle = `rgba(110, 231, 255, ${alpha * 0.6})`;
                ctx.beginPath();
                ctx.arc(t.x, t.y, ball.r * 0.8, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.fillStyle = '#6ee7ff';
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
            ctx.fill();

            if (state === 'paused') {
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(0, 0, width, height);
                ctx.fillStyle = '#f1f3ff';
                ctx.font = 'bold 28px Poppins';
                ctx.textAlign = 'center';
                ctx.fillText('Paused', width / 2, height / 2);
            }
            if (state === 'ready' && hasStarted) {
                ctx.fillStyle = 'rgba(255,255,255,0.08)';
                ctx.fillRect(0, 0, width, height);
                ctx.fillStyle = '#e5e7ff';
                ctx.font = 'bold 22px Poppins';
                ctx.textAlign = 'center';
                ctx.fillText('Press Space to Serve', width / 2, height / 2);
            }
        }

        function tick() {
            if (state === 'running') {
                movePaddles();
                stepBall();
            } else if (state === 'ready') {
                movePaddles();
            }
        }

        function loop(now) {
            requestAnimationFrame(loop);
            if (!lastTime) lastTime = now;
            const frameDelta = Math.min(MAX_FRAME_MS, now - lastTime);
            lastTime = now;
            accumulator += frameDelta;

            let steps = 0;
            while (accumulator >= STEP_MS && steps < MAX_STEPS_PER_FRAME) {
                tick();
                accumulator -= STEP_MS;
                steps += 1;
            }
            if (steps === MAX_STEPS_PER_FRAME) accumulator = 0;

            updateHud();
            draw();
        }

        pauseBtn.addEventListener('click', togglePause);
        restartBtn.addEventListener('click', resetMatch);
        playAgainBtn.addEventListener('click', resetMatch);
        startBtn.addEventListener('click', startOrServe);
        window.addEventListener('resize', () => { resizeCanvas(); draw(); });

        resizeCanvas();
        resetMatch();
        requestAnimationFrame(loop);
        
        // Initialize sound button
        soundBtn.textContent = soundEngine.isEnabled() ? 'üîä' : 'üîá';
        soundBtn.addEventListener('click', () => {
            soundEngine.init();
            soundEngine.toggle();
            soundBtn.textContent = soundEngine.isEnabled() ? 'üîä' : 'üîá';
            soundEngine.click();
        });
    </script>
</body>
</html>
