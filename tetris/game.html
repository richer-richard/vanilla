<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris — Play | VANILLA</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700;800&family=Press+Start+2P&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../styles.css">
    <style>
        body {
            min-height: 100vh;
        }

        header {
            padding: 16px 28px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: linear-gradient(90deg, rgba(102, 126, 234, 0.12), rgba(118, 75, 162, 0.1));
            border-bottom: 1px solid rgba(102, 126, 234, 0.3);
            position: sticky;
            top: 0;
            z-index: 5;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .crumb {
            color: #cdd2f1;
            letter-spacing: 0.6px;
            font-size: 12px;
        }

        .pill {
            padding: 10px 14px;
            border-radius: 12px;
            border: 1px solid rgba(102, 126, 234, 0.4);
            background: rgba(102, 126, 234, 0.12);
            color: #dfe4ff;
            font-weight: 700;
            font-size: 12px;
            letter-spacing: 0.4px;
        }

        .pill-link {
            text-decoration: none;
            color: #dfe4ff;
            border: 1px solid rgba(102, 126, 234, 0.4);
            padding: 10px 12px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.04);
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            letter-spacing: 0.8px;
            transition: all 0.2s ease;
        }

        .pill-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 24px rgba(0, 0, 0, 0.35);
            border-color: rgba(118, 75, 162, 0.75);
        }

        .header-actions {
            display: flex;
            gap: 10px;
        }

        .action-btn {
            padding: 10px 14px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.24), rgba(118, 75, 162, 0.2));
            color: #f2f4ff;
            font-weight: 700;
            letter-spacing: 0.3px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .action-btn.ghost {
            background: rgba(255, 255, 255, 0.06);
            border-color: rgba(255, 255, 255, 0.1);
        }

        .action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
        }

        main {
            width: min(1200px, 100%);
            margin: 0 auto;
            padding: 26px 24px 60px;
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 18px;
            align-items: start;
        }

        @media (max-width: 980px) {
            main {
                grid-template-columns: 1fr;
            }
        }

        .glass-card {
            background: linear-gradient(150deg, rgba(255, 255, 255, 0.02), rgba(102, 126, 234, 0.08));
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            box-shadow: 0 25px 70px rgba(0, 0, 0, 0.35), 0 10px 22px rgba(102, 126, 234, 0.1);
            padding: 18px;
            position: relative;
            overflow: hidden;
        }

        .glass-card::after {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 12% 18%, rgba(118, 75, 162, 0.14), transparent 32%),
                        radial-gradient(circle at 82% 8%, rgba(102, 126, 234, 0.12), transparent 30%);
            pointer-events: none;
        }

        .glass-card > * {
            position: relative;
            z-index: 1;
        }

        .hud {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-bottom: 12px;
        }

        .stat {
            padding: 12px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            background: rgba(255, 255, 255, 0.03);
        }

        .stat .label {
            font-size: 11px;
            color: #adb6da;
            letter-spacing: 0.6px;
            text-transform: uppercase;
        }

        .stat .value {
            font-size: 22px;
            font-weight: 800;
            margin-top: 4px;
        }

        .board-shell {
            margin-top: 8px;
            background: radial-gradient(circle at 20% 20%, rgba(102, 126, 234, 0.16), transparent 35%),
                        radial-gradient(circle at 80% 10%, rgba(118, 75, 162, 0.16), transparent 30%),
                        rgba(6, 9, 25, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            padding: 14px;
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.03);
            display: grid;
            grid-template-columns: 2.6fr 1fr;
            gap: 14px;
        }

        .canvas-wrap {
            background: #050913;
            border-radius: 12px;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: auto;
            display: block;
            background: #050913;
        }

        .panel {
            padding: 10px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            background: rgba(255, 255, 255, 0.02);
            color: #dfe4ff;
        }

        .panel h3 {
            margin: 0 0 6px;
            font-size: 14px;
            letter-spacing: 0.6px;
            text-transform: uppercase;
            color: #9fb0ff;
        }

        .next-canvas {
            width: 100%;
            aspect-ratio: 1 / 1;
            background: rgba(5, 9, 19, 0.9);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .sidebar h2 {
            margin: 6px 0 12px;
            font-size: 20px;
        }

        .tips {
            list-style: none;
            padding-left: 0;
            display: flex;
            flex-direction: column;
            gap: 10px;
            color: #cbd0ea;
        }

        .tips li {
            padding: 10px 12px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            background: rgba(255, 255, 255, 0.03);
        }

        .chip-row {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 14px;
        }

        .chip {
            padding: 8px 12px;
            border-radius: 10px;
            border: 1px solid rgba(102, 126, 234, 0.35);
            background: rgba(102, 126, 234, 0.08);
            color: #dfe4ff;
            font-weight: 600;
            font-size: 12px;
        }

        .eyebrow {
            letter-spacing: 1px;
            text-transform: uppercase;
            color: #9fb0ff;
            font-size: 11px;
        }
    </style>
</head>
<body class="game-page">
    <header>
        <div class="header-left">
            <a class="pill-link" href="../games.html">← Games</a>
            <span class="crumb">Tetris</span>
            <span class="pill" id="difficultyLabel">Medium Drop</span>
        </div>
        <div class="header-actions">
            <button class="action-btn ghost" id="pauseBtn">Pause</button>
            <button class="action-btn" id="restartBtn">Restart</button>
        </div>
    </header>

    <main>
        <section class="glass-card">
            <div class="hud">
                <div class="stat">
                    <div class="label">Score</div>
                    <div class="value" id="score">0</div>
                </div>
                <div class="stat">
                    <div class="label">Lines</div>
                    <div class="value" id="lines">0</div>
                </div>
                <div class="stat">
                    <div class="label">Level</div>
                    <div class="value" id="level">1</div>
                </div>
                <div class="stat">
                    <div class="label">Pace</div>
                    <div class="value" id="pace">--</div>
                </div>
            </div>
            <div class="board-shell">
                <div class="canvas-wrap">
                    <canvas id="board"></canvas>
                </div>
                <div class="panel">
                    <h3>Next</h3>
                    <canvas id="next" class="next-canvas"></canvas>
                    <div style="margin-top:10px;color:#cdd2f1;font-size:12px;line-height:1.6;">
                        <div>Controls:</div>
                        <div>←/→: Move</div>
                        <div>↑ or W: Rotate</div>
                        <div>↓: Soft drop</div>
                        <div>Space: Hard drop</div>
                        <div>P: Pause • R: Restart</div>
                    </div>
                </div>
            </div>
        </section>

        <aside class="glass-card sidebar">
            <div class="eyebrow">Keep the stack clean</div>
            <h2>Stay flat, clear faster</h2>
            <ul class="tips">
                <li>Keep the well open and burn singles to avoid messy tops.</li>
                <li>Rotate early, especially with long bars and L/J pieces.</li>
                <li>Use soft drops to finesse, hard drops to commit.</li>
            </ul>
            <div class="chip-row">
                <span class="chip">Bag randomizer</span>
                <span class="chip">Line clears ramp speed</span>
                <span class="chip">Per-difficulty best saved locally</span>
            </div>
        </aside>
    </main>

    <div class="game-over-overlay" id="gameOverOverlay">
        <div class="game-over-content">
            <h1 id="gameOverTitle">Game Over</h1>
            <p id="finalScore">Score: 0</p>
            <p id="finalLines">Lines: 0</p>
            <div class="game-over-buttons">
                <button class="game-over-btn" id="playAgain">Play Again</button>
                <button class="game-over-btn" onclick="window.location.href='../games.html'">Back to Menu</button>
            </div>
        </div>
    </div>

    <script>
        const boardCanvas = document.getElementById('board');
        const boardCtx = boardCanvas.getContext('2d');
        const nextCanvas = document.getElementById('next');
        const nextCtx = nextCanvas.getContext('2d');

        const scoreEl = document.getElementById('score');
        const linesEl = document.getElementById('lines');
        const levelEl = document.getElementById('level');
        const paceEl = document.getElementById('pace');
        const difficultyLabel = document.getElementById('difficultyLabel');
        const overlay = document.getElementById('gameOverOverlay');
        const finalScoreEl = document.getElementById('finalScore');
        const finalLinesEl = document.getElementById('finalLines');
        const playAgainBtn = document.getElementById('playAgain');
        const pauseBtn = document.getElementById('pauseBtn');
        const restartBtn = document.getElementById('restartBtn');

        const params = new URLSearchParams(window.location.search);
        const requestedDifficulty = (params.get('difficulty') || 'medium').toLowerCase();

        const CONFIG = {
            easy: { drop: 950, lockDelay: 550, label: 'Easy' },
            medium: { drop: 700, lockDelay: 450, label: 'Medium' },
            hard: { drop: 520, lockDelay: 380, label: 'Hard' }
        };

        const settings = CONFIG[requestedDifficulty] || CONFIG.medium;
        difficultyLabel.textContent = `${settings.label} • 10 × 20`;

        const bestKey = `vanilla-tetris-${settings.label.toLowerCase()}-best`;
        let bestScore = Number(localStorage.getItem(bestKey)) || 0;

        const COLS = 10;
        const ROWS = 20;
        const COLORS = {
            I: '#6ee7ff',
            O: '#fcd34d',
            T: '#c084fc',
            S: '#4ade80',
            Z: '#fb7185',
            J: '#93c5fd',
            L: '#f59e0b'
        };

        const SHAPES = {
            I: [[0,1],[1,1],[2,1],[3,1]],
            O: [[1,0],[2,0],[1,1],[2,1]],
            T: [[1,0],[0,1],[1,1],[2,1]],
            S: [[1,1],[2,1],[0,2],[1,2]],
            Z: [[0,1],[1,1],[1,2],[2,2]],
            J: [[0,0],[0,1],[1,1],[2,1]],
            L: [[2,0],[0,1],[1,1],[2,1]]
        };

        let board = [];
        let bag = [];
        let current = null;
        let nextPiece = null;
        let dropInterval = settings.drop;
        let lastTime = 0;
        let dropAccumulator = 0;
        let state = 'running'; // running | paused | over
        let score = 0;
        let lines = 0;
        let level = 1;
        let lockTimer = 0;
        let lockDelay = settings.lockDelay;

        function resizeCanvas() {
            const container = boardCanvas.parentElement;
            const width = container.clientWidth;
            const maxHeight = Math.max(420, window.innerHeight - 260);
            const size = Math.min(width, maxHeight * 0.95);
            boardCanvas.width = Math.floor(size * 0.7);
            boardCanvas.height = Math.floor(size);
            draw();
        }

        function createMatrix() {
            return Array.from({ length: ROWS }, () => Array(COLS).fill(null));
        }

        function makeBag() {
            const keys = Object.keys(SHAPES);
            const shuffled = [...keys].sort(() => Math.random() - 0.5);
            bag.push(...shuffled);
        }

        function spawnPiece() {
            if (bag.length === 0) makeBag();
            const type = bag.shift();
            const shape = SHAPES[type].map(([x, y]) => ({ x, y }));
            return {
                type,
                shape,
                pos: { x: 3, y: -2 },
                color: COLORS[type]
            };
        }

        function resetGame() {
            overlay.classList.remove('active');
            board = createMatrix();
            bag = [];
            current = spawnPiece();
            nextPiece = spawnPiece();
            score = 0;
            lines = 0;
            level = 1;
            dropInterval = settings.drop;
            lockDelay = settings.lockDelay;
            state = 'running';
            updateHud();
            drawNext();
        }

        function updateHud() {
            scoreEl.textContent = score;
            linesEl.textContent = lines;
            levelEl.textContent = level;
            paceEl.textContent = `${Math.round(1000 / dropInterval)} drops/s`;
        }

        function collide(piece) {
            return piece.shape.some(cell => {
                const x = piece.pos.x + cell.x;
                const y = piece.pos.y + cell.y;
                return x < 0 || x >= COLS || y >= ROWS || (y >= 0 && board[y][x]);
            });
        }

        function rotate(shape, dir = 1) {
            return shape.map(cell => ({
                x: dir > 0 ? cell.y : -cell.y,
                y: dir > 0 ? -cell.x : cell.x
            }));
        }

        function attemptRotate(dir) {
            const rotated = rotate(current.shape, dir);
            const kicks = [{x:0,y:0},{x:1,y:0},{x:-1,y:0},{x:0,y:-1},{x:0,y:1}];
            for (const kick of kicks) {
                const test = { ...current, shape: rotated.map(c => ({...c})), pos: { x: current.pos.x + kick.x, y: current.pos.y + kick.y } };
                if (!collide(test)) {
                    current.shape = rotated;
                    current.pos = test.pos;
                    return;
                }
            }
        }

        function hardDrop() {
            while (!collide({...current, pos: { x: current.pos.x, y: current.pos.y + 1 }})) {
                current.pos.y += 1;
                score += 2;
            }
            lockPiece();
        }

        function softDrop() {
            if (!collide({...current, pos: { x: current.pos.x, y: current.pos.y + 1 }})) {
                current.pos.y += 1;
                score += 1;
            } else {
                lockTimer += dropInterval;
                if (lockTimer >= lockDelay) {
                    lockPiece();
                }
            }
        }

        function mergePiece() {
            current.shape.forEach(cell => {
                const x = current.pos.x + cell.x;
                const y = current.pos.y + cell.y;
                if (y >= 0 && y < ROWS && x >= 0 && x < COLS) {
                    board[y][x] = current.color;
                }
            });
        }

        function clearLines() {
            let cleared = 0;
            for (let y = board.length - 1; y >= 0; y--) {
                if (board[y].every(Boolean)) {
                    board.splice(y, 1);
                    board.unshift(Array(COLS).fill(null));
                    cleared++;
                    y++;
                }
            }
            if (cleared > 0) {
                const scores = [0, 100, 250, 500, 800];
                score += scores[cleared] * level;
                lines += cleared;
                level = 1 + Math.floor(lines / 10);
                dropInterval = Math.max(120, settings.drop * Math.pow(0.93, level - 1));
                lockDelay = Math.max(220, settings.lockDelay - (level * 8));
            }
        }

        function lockPiece() {
            mergePiece();
            clearLines();
            current = nextPiece;
            nextPiece = spawnPiece();
            lockTimer = 0;
            if (collide(current)) {
                endGame();
            }
            updateHud();
            drawNext();
        }

        function endGame() {
            state = 'over';
            if (score > bestScore) {
                bestScore = score;
                localStorage.setItem(bestKey, bestScore);
            }
            finalScoreEl.textContent = `Score: ${score}`;
            finalLinesEl.textContent = `Lines: ${lines}`;
            overlay.classList.add('active');
        }

        function drawCell(ctx, x, y, size, color) {
            ctx.fillStyle = color;
            ctx.strokeStyle = 'rgba(0,0,0,0.35)';
            ctx.lineWidth = Math.max(1, size * 0.06);
            ctx.beginPath();
            ctx.roundRect(x + 1, y + 1, size - 2, size - 2, Math.min(6, size / 3));
            ctx.fill();
            ctx.stroke();
        }

        function drawGrid(ctx, width, height, size) {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.04)';
            ctx.lineWidth = 1;
            for (let x = 0; x <= width; x++) {
                ctx.beginPath();
                ctx.moveTo(x * size, 0);
                ctx.lineTo(x * size, height * size);
                ctx.stroke();
            }
            for (let y = 0; y <= height; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * size);
                ctx.lineTo(width * size, y * size);
                ctx.stroke();
            }
        }

        function draw() {
            const cellSize = Math.floor(boardCanvas.width / COLS);
            boardCanvas.height = cellSize * ROWS;

            const gradient = boardCtx.createLinearGradient(0, 0, 0, boardCanvas.height);
            gradient.addColorStop(0, '#0c132b');
            gradient.addColorStop(1, '#0a0f22');
            boardCtx.fillStyle = gradient;
            boardCtx.fillRect(0, 0, boardCanvas.width, boardCanvas.height);

            drawGrid(boardCtx, COLS, ROWS, cellSize);

            board.forEach((row, y) => {
                row.forEach((cell, x) => {
                    if (cell) {
                        drawCell(boardCtx, x * cellSize, y * cellSize, cellSize, cell);
                    }
                });
            });

            if (state !== 'over') {
                current.shape.forEach(cell => {
                    const x = (current.pos.x + cell.x) * cellSize;
                    const y = (current.pos.y + cell.y) * cellSize;
                    drawCell(boardCtx, x, y, cellSize, current.color);
                });
            }

            if (state === 'paused') {
                boardCtx.fillStyle = 'rgba(0, 0, 0, 0.45)';
                boardCtx.fillRect(0, 0, boardCanvas.width, boardCanvas.height);
                boardCtx.fillStyle = '#f1f3ff';
                boardCtx.font = `bold ${Math.max(22, cellSize)}px Poppins`;
                boardCtx.textAlign = 'center';
                boardCtx.fillText('Paused', boardCanvas.width / 2, boardCanvas.height / 2);
            }
        }

        function drawNext() {
            const size = nextCanvas.width = nextCanvas.clientWidth;
            nextCanvas.height = size;
            const ctx = nextCtx;
            ctx.clearRect(0, 0, size, size);
            ctx.fillStyle = '#050913';
            ctx.fillRect(0, 0, size, size);
            const cells = nextPiece.shape;
            const maxX = Math.max(...cells.map(c => c.x));
            const maxY = Math.max(...cells.map(c => c.y));
            const minX = Math.min(...cells.map(c => c.x));
            const minY = Math.min(...cells.map(c => c.y));
            const spanX = maxX - minX + 1;
            const spanY = maxY - minY + 1;
            const cellSize = Math.floor(size / Math.max(spanX + 2, spanY + 2));
            const offsetX = Math.floor((size - spanX * cellSize) / 2) - minX * cellSize;
            const offsetY = Math.floor((size - spanY * cellSize) / 2) - minY * cellSize;
            cells.forEach(cell => {
                drawCell(ctx, offsetX + cell.x * cellSize, offsetY + cell.y * cellSize, cellSize, nextPiece.color);
            });
        }

        function update(time = 0) {
            const delta = time - lastTime;
            lastTime = time;
            if (state === 'running') {
                dropAccumulator += delta;
                if (dropAccumulator >= dropInterval) {
                    softDrop();
                    dropAccumulator = 0;
                }
            }
            draw();
            requestAnimationFrame(update);
        }

        function togglePause() {
            if (state === 'over') return;
            state = state === 'paused' ? 'running' : 'paused';
            pauseBtn.textContent = state === 'paused' ? 'Resume' : 'Pause';
        }

        document.addEventListener('keydown', (event) => {
            if (state === 'over') return;
            const key = event.key.toLowerCase();
            const tryMove = (dx, dy) => {
                const test = { ...current, pos: { x: current.pos.x + dx, y: current.pos.y + dy } };
                if (!collide(test)) {
                    current.pos = test.pos;
                    if (dy > 0) score += 1;
                }
            };

            if (key === 'p') {
                togglePause();
                return;
            }
            if (key === 'r') {
                resetGame();
                return;
            }
            if (state === 'paused') return;

            if (key === 'arrowleft' || key === 'a') {
                event.preventDefault();
                tryMove(-1, 0);
            } else if (key === 'arrowright' || key === 'd') {
                event.preventDefault();
                tryMove(1, 0);
            } else if (key === 'arrowdown' || key === 's') {
                event.preventDefault();
                softDrop();
            } else if (key === ' ' || key === 'arrowup' || key === 'w') {
                event.preventDefault();
                attemptRotate(1);
            } else if (key === 'shift') {
                event.preventDefault();
                attemptRotate(-1);
            } else if (key === 'enter') {
                event.preventDefault();
                hardDrop();
            }
        });

        pauseBtn.addEventListener('click', togglePause);
        restartBtn.addEventListener('click', resetGame);
        playAgainBtn.addEventListener('click', resetGame);
        window.addEventListener('resize', () => {
            resizeCanvas();
            draw();
        });

        resizeCanvas();
        resetGame();
        updateHud();
        requestAnimationFrame(update);
    </script>
</body>
</html>
